#!/usr/bin/env python3

"""
Created on Thu Apr  1 11:11:14 2021

@author: Alvaro Gonzalez Bilbao
@version: 1.12 (28/05/21)

This code is used to read the results generated by read_debris_case.py and to generate figure from them.
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from matplotlib.pyplot import text
from matplotlib.ticker import (AutoMinorLocator, MultipleLocator)
import os
import shutil
import math

def clean_brackets(list):
    k = 0
    while True:
        repeat = 'False'
        if list[k]=='[':
            list.remove('[')
            repeat = 'True'
        elif list[k]==']':
            list.remove(']')
            repeat = 'True'
        elif list[k][-1]==']':
            list[k] = list[k][:-1]
            repeat = 'True'    
        elif list[k][0]=='[':
            list[k] = list[k][1:]
            repeat = 'True'  
        elif list[k]=='(':
            list.remove('(')
            repeat = 'True'
        elif list[k]==')':
            list.remove(')')
            repeat = 'True'
        elif list[k][-1]==')':
            list[k] = list[k][:-1]
            repeat = 'True'    
        elif list[k][0]=='(':
            list[k] = list[k][1:]
            repeat = 'True' 
        if repeat == 'False':
            k = k+1
        if k == len(list):
            break

def clean_dots(list):
    k = 0
    while True:
        repeat = 'False'
        if list[k]==';':
            list.remove(';')
            repeat = 'True'
        elif list[k][-1]==';':
            list[k] = list[k][:-1]
            repeat = 'True'
        if repeat == 'False':
            k = k+1
        if k == len(list):
            break

def clean_spaces_string(list):
    k = 0
    while True:
        if list[k] == '\n':
            list.remove('\n')
        elif list[k].split()[0] == '//':
            list.remove(list[k])
        else: 
            k += 1
        if k == len(list):
            break

def clean_spaces_list(list):
    k = 0
    while True:
        if len(list[k]) == 0:
            list.remove([])
        else: 
            k += 1
        if k == len(list):
            break

def read_entry(list,dict):
    dict[list[0]] = list[1]
    
def read_dimensionedScalar(value,dict):
    dict['name']=value[0]
    dimensions_list = []
    for j in range(7):
        dimensions_list.append(float(value[1+j]))
    dict['dimensions']=dimensions_list
    dict['value']=float(value[-1])

def read_vector(value,list):
    clean_brackets(value)
    if len(value)==3:
        for i in range(len(value)):
            value[i] = float(value[i])
    list.append(value)

def read_constant(list, dict):
    value = list[1:]
    clean_brackets(value)
    subdict = {}
    sublist = []
    if len(value)== 9:
        read_dimensionedScalar(value,subdict)
        dict[list[0]] = subdict
    else:
        read_vector(value,sublist)
        dict[list[0]] = sublist
        
def read_subdictionary(list,output,name,type):
    subdict = {}
    while True:
        pop = list.pop(0)
        if pop[0] == '}':
            break
        clean_brackets(pop)
        if len(pop)==2:
            read_entry(pop,subdict)
        elif len(pop)>2:
            read_constant(pop,subdict)
        else:
            if list[0][0]=='{':
                list.remove(list[0])
                read_subdictionary(list,subdict,pop[0],'dict')
            elif list[0][0]=='(':
                list.remove(list[0])
                read_sublist(list,subdict,pop[0],'dict')
    if type == 'dict':
        output[name] = subdict
    elif type == 'list':
        output.append(name)
        output.append(subdict)

def read_sublist(list,output,name,type):
    sublist = []
    while True:
        pop = list.pop(0)
        if pop[0] == ')':
            break
        clean_brackets(pop)
        if len(pop)==1:
            if list[0][0]=='{':
                list.remove(list[0])
                read_subdictionary(list,sublist,pop[0],'list')
            else:
                sublist.append(pop[0])
        elif len(pop) > 1:
            read_vector(pop,sublist)
    if type == 'dict':
        output[name] = sublist
    elif type == 'list':
        output.append(name)
        output.append(sublist)

def read_dictionary(list,dict):
    while True:
        pop = list.pop(0)
        if len(pop)==2:
            read_entry(pop,dict)
        elif len(pop)==1:
            if list[0][0]=='{':
                list.remove(list[0])
                read_subdictionary(list,dict,pop[0],'dict')
            elif list[0][0]=='(':
                list.remove(list[0])
                read_sublist(list,dict,pop[0],'dict')
        elif len(pop)>2:
            read_constant(pop,dict)          
        if len(list) == 0:
            break

def get_input(path,list, OF_header = True):
    input = []
    with open(path) as f:
        for line in f:
            input.append(line)
    if OF_header == True:
        input= input[16:(len(input))]
    clean_spaces_string(input)
    for i in range(len(input)):
        list.append(input[i].split())
        clean_dots(list[i])
    clean_spaces_list(list)

def read_dict(path, name, output):
    list = []
    get_input(path+'/'+name, list, False)
    while True:
        pop = list.pop(0)
        if len(pop)==1 and pop[0] != '{' and pop[0] != '}':
            if list[0][0]=='{':
                list.remove(list[0])
                sub_list = []
                while True:
                    if list[0][0]=='}':
                        list.remove(list[0])
                        break
                    new_list = list.pop(0)
                    for i in range(len(new_list)):
                        new_list[i] = float(new_list[i])
                    sub_list.append(new_list)
                if len(sub_list) == 1:
                    output[pop[0]] = sub_list[0]
                else:
                    output[pop[0]] = sub_list
        if len(list) == 0:
            break
                        
def read_list(path, name, output):
    list = []
    get_input(path+'/'+name,list, False)    
    for i in range(len(list[0])):
        output.append(float(list[0][i]))    

def read_matrix(path, name, output):
    list = []
    get_input(path+'/'+name,list, False)
    for j in range(len(list)):                    
        for i in range(len(list[j])):
            output[i,j] = float(list[j][i])

def read_value(path, name, output, time, index):
    list = []
    get_input(path+'/'+name,list, False)
    if index == -1:
        output[time, 0] = float(list[0][0])
    else:
        output[time, index] = float(list[0][0])

class vector:
        def __init__(self,x=0, y=0, z=0):
                self.x= float(x)
                self.y= float(y)
                self.z= float(z)
                
        def List(self):
                return [self.x,self.y,self.z]
                    
        def mag(self):
                return round(math.sqrt(self.x**2+self.y**2+self.z**2),6)
            
        def __add__(self,other):
                return vector(self.x+other.x,self.y+other.y,self.z+other.z)
            
        def __sub__(self,other):
                return vector(self.x-other.x,self.y-other.y,self.z-other.z)
            
        def __mul__(self,alpha):
                return vector(self.x*alpha,self.y*alpha,self.z*alpha)
            
        def __truediv__(self,alpha):
                return vector(self.x/alpha,self.y/alpha,self.z/alpha)

        def __eq__(self, other):
                if self.x == other.x and self.y == other.y and self.z == other.z:
                    return True
                else:
                    return False
          
        def angle(self):              
            if self.x != 0 and self.y != 0:
                if self.x > 0 and self.y > 0:
                    angle = math.atan(self.y/self.x)
                elif self.x < 0:
                    angle = math.pi+math.atan(self.y/self.x)
                else:
                    angle = 2*math.pi+math.atan(self.y/self.x)
            elif self.x == 0:
                if self.y > 0:
                    angle = math.pi/2
                else:
                    angle = 3*math.pi/2
            else:
                if self.x > 0:
                    angle = 0
                else:
                    angle = math.pi                
            return angle

def distxy(v1,v2):
        return round(math.sqrt((v1.x-v2.x)**2+(v1.y-v2.y)**2),6)

def dist(v1,v2):
        return round(math.sqrt((v1.x-v2.x)**2+(v1.y-v2.y)**2+(v1.z-v2.z)**2),6)

#This class is used to read the results written by the output class //AG
class Results:
        def __init__(self, path, name = 'Results', basic = 'on', h='off',pb='off',Cv='off',deltaz0='off',Us='off',tau='off',phi2s='off',Q='off',Sm='off',rho='off',V='off',M='off',Vsed='off',rcg='off'):
                self.x = []
                self.y = []
                self.z = []
                self.he = []
                self.t = []
                self.p = path+'/'+name #The folder where the results were written.
                self.tps = {}
                                
                self.h = []
                self.pb = []
                self.Cv = []
                self.deltah0 = []
                self.deltac0 = []
                self.Us = []
                self.tau = []
                self.Sm = []
                self.rho = []
                
                self.rcg = []
                self.M = []
                self.V = []
                self.Cv_avrg = []
                self.Vsed = []
                self.rF_V = []
                self.rF_M = []
                
                self.lp = {}
                self.lp_c = {}
                self.tp = {}
                
                self.phi2s = {}  
                self.Q = {}

                self.z_tp = {}
                self.he_tp = {}
                self.h_tp = {}
                self.Us_m_tp = {}
                self.deltah0_tp = {}
                self.deltac0_tp = {}
                
                self.h_tp_max = {}
                self.deltac0_tp_max = {}
                self.deltah0_tp_max = {}
                self.Us_m_tp_max = {}
                self.z_tp_min = {}

                self.basic_flag = basic
                self.h_flag = h
                self.pb_flag = pb
                self.Cv_flag = Cv
                self.deltaz0_flag = deltaz0
                self.Us_flag = Us
                self.tau_flag = tau
                self.Q_flag = Q
                self.phi2s_flag = phi2s
                self.Sm_flag = Sm
                self.rho_flag = rho
                self.V_flag = V
                self.M_flag = M
                self.Vsed_flag = Vsed
                self.rcg_flag = rcg
                
                self.VELFP = []
                self.DEPFP = []

                self.get_case()

        def get_case(self):
                self.get_x()
                self.get_y()
                self.get_t()                
                self.get_lp()
                self.get_tp()
                
        def get_all(self):                
                self.get_all_fields()
                self.get_all_fields_tp()
                self.get_all_edge_fields()
                self.get_all_time_fields()

        def get_all_fields(self):
                self.get_z()
                self.get_he()
                self.get_h()
                self.get_pb()
                self.get_Cv()
                self.get_deltah0()
                self.get_deltac0()
                self.get_Us()
                self.get_tau()
                self.get_Sm()
                self.get_rho() 

        def get_all_fields_tp(self):            
                self.get_z_tp()
                self.get_he_tp()
                self.get_h_tp()
                self.get_Us_m_tp()
                self.get_deltah0_tp()
                self.get_deltac0_tp()

        def get_all_edge_fields(self):
                self.get_phi2s()
                self.get_Q()            

        def get_all_time_fields(self):
                self.get_V()
                self.get_M()
                self.get_Cv_avrg()
                self.get_Vsed()
                self.get_rcg()
                self.get_rF_VyM()            
            
        def get_V(self):
                if self.V_flag == 'on' or self.V_flag == 'yes' or self.V_flag == True:
                    self.V = np.zeros((len(self.t), 1))
                    self.read_scalartimefield('V', self.V, -1)

        def get_M(self):
                if self.M_flag == 'on' or self.M_flag == 'yes' or self.M_flag == True:
                    self.M = np.zeros((len(self.t), 1))
                    self.read_scalartimefield('M', self.M, -1)

        def get_Cv_avrg(self):
                if len(self.M) == 0:
                    self.activate_M()
                    self.get_M()
                if len(self.V) == 0:
                    self.activate_V()
                    self.get_V()
                if self.tps == {}:
                    list = []
                    get_input(self.p+'/transportProperties',list)    
                    read_dictionary(list,self.tps)
                rho_w = self.tps['rho_w']['value']
                rho_s = self.tps['rho_s']['value']                  
                self.Cv_avrg = np.zeros((len(self.t),1))
                for t in range(len(self.t)):
                    self.Cv_avrg[t,0] = ((self.M[t,0]/(self.V[t,0]+0.0001))-rho_w)/(rho_s-rho_w)
                self.clean_M()
                self.clean_V()

        def get_Vsed(self):
                if self.Vsed_flag == 'on' or self.Vsed_flag == 'yes' or self.Vsed_flag == True:
                    self.Vsed = np.zeros((len(self.t), 1))
                    self.read_scalartimefield('Vsed', self.Vsed, -1)

        def get_rcg(self):
                if self.rcg_flag == 'on' or self.rcg_flag == 'yes' or self.rcg_flag == True:
                    self.rcg = np.zeros((len(self.t), 3))
                    self.read_scalartimefield('rcg_x', self.rcg, 0)
                    self.read_scalartimefield('rcg_y', self.rcg, 1)
                    self.read_scalartimefield('rcg_z', self.rcg, 2)

        def read_scalartimefield(self, name, output, index):
                listdir = os.listdir(self.p+'/'+ str(self.t[0]))
                if name in listdir:               
                    for t in range(len(self.t)):
                        read_value(self.p+'/'+str(self.t[t]), name, output, t, index)
              
        def get_x(self):
                if self.basic_flag == 'on' or self.basic_flag == 'yes' or self.basic_flag == True:
                    read_list(self.p, 'x', self.x)

        def get_y(self):
                if self.basic_flag == 'on' or self.basic_flag == 'yes' or self.basic_flag == True:
                    read_list(self.p, 'y', self.y)

        def get_rF_VyM(self):
                read_list(self.p, 'rF_V', self.rF_V)
                read_list(self.p, 'rF_M', self.rF_M)

        def get_z(self):
                if self.basic_flag == 'on' or self.basic_flag == 'yes' or self.basic_flag == True:
                    self.z = np.zeros((len(self.x),len(self.y)))
                    read_matrix(self.p, 'z', self.z)

        def get_he(self):
                self.he = np.zeros((len(self.x),len(self.y)))
                read_matrix(self.p, 'he', self.he)
                
        def get_t(self):
                if self.basic_flag == 'on' or self.basic_flag == 'yes' or self.basic_flag == True:
                    read_list(self.p, 't', self.t)
                    for i in range(len(self.t)):
                        if float(self.t[i]) == int(self.t[i]):
                            self.t[i] = int(self.t[i])                  

        def get_h(self):
                if self.h_flag == 'on' or self.h_flag == 'yes' or self.h_flag == True:
                    self.h = np.zeros((len(self.t), len(self.x),len(self.y)))
                    self.read_scalarfield('h', self.h)
                
        def get_pb(self):
                if self.pb_flag == 'on' or self.pb_flag == 'yes' or self.pb_flag == True:
                    self.pb = np.zeros((len(self.t), len(self.x),len(self.y)))
                    self.read_scalarfield('pb', self.pb)

        def get_Cv(self):
                if self.Cv_flag == 'on' or self.Cv_flag == 'yes' or self.Cv_flag == True:
                    self.Cv = np.zeros((len(self.t), len(self.x),len(self.y)))
                    self.read_scalarfield('Cv', self.Cv)

        def get_deltah0(self):
                if self.deltaz0_flag == 'on' or self.deltaz0_flag == 'yes' or self.deltaz0_flag == True:
                    self.deltah0 = np.zeros((len(self.t), len(self.x),len(self.y)))
                    self.read_scalarfield('deltah0', self.deltah0)
                
        def get_deltac0(self):
                if self.deltaz0_flag == 'on' or self.deltaz0_flag == 'yes' or self.deltaz0_flag == True:
                    self.deltac0 = np.zeros((len(self.t), len(self.x),len(self.y)))
                    self.read_scalarfield('deltac0', self.deltac0)

        def get_Sm(self):
                if self.Sm_flag == 'on' or self.Sm_flag == 'yes' or self.Sm_flag == True:
                    self.Sm = np.zeros((len(self.t), len(self.x),len(self.y)))
                    self.read_scalarfield('Sm', self.Sm)

        def get_rho(self):
                if self.rho_flag == 'on' or self.rho_flag == 'yes' or self.rho_flag == True:
                    self.rho = np.zeros((len(self.t), len(self.x),len(self.y)))
                    self.read_scalarfield('rho', self.rho)
                
        def get_Us(self):
                if self.Us_flag == 'on' or self.Us_flag == 'yes' or self.Us_flag == True:
                    self.Us = np.zeros((len(self.t), len(self.x),len(self.y),3))
                    self.Us_m = np.zeros((len(self.t), len(self.x),len(self.y)))
                    self.read_scalarfield('Us_x', self.Us[:,:,:,0])
                    self.read_scalarfield('Us_y', self.Us[:,:,:,1])
                    self.read_scalarfield('Us_z', self.Us[:,:,:,2])
                    self.read_scalarfield('Us_m', self.Us_m)

        def get_tau(self):
                if self.tau_flag == 'on' or self.tau_flag == 'yes' or self.tau_flag == True:
                    self.tau = np.zeros((len(self.t), len(self.x),len(self.y),3))
                    self.tau_m = np.zeros((len(self.t), len(self.x),len(self.y)))
                    self.read_scalarfield('tau_x', self.tau[:,:,:,0])
                    self.read_scalarfield('tau_y', self.tau[:,:,:,1])
                    self.read_scalarfield('tau_z', self.tau[:,:,:,2])
                    self.read_scalarfield('tau_m', self.tau_m)

        def read_scalarfield(self, name, output):
                listdir = os.listdir(self.p+'/'+ str(self.t[0]))
                if name in listdir:               
                    for t in range(len(self.t)):
                        read_matrix(self.p+'/'+str(self.t[t]), name, output[t,:,:])

        def get_lp(self):
                if self.basic_flag == 'on' or self.basic_flag == 'yes' or self.basic_flag == True:
                    listdir = os.listdir(self.p)
                    if 'lp' in listdir:            
                        read_dict(self.p, 'lp', self.lp)
                        lp_cx = {}
                        lp_cy = {}
                        read_dict(self.p, 'lp_cx', lp_cx)
                        read_dict(self.p, 'lp_cy', lp_cy)                    
                        for key in lp_cx.keys():
                            list = []
                            for j in range(len(lp_cx[key])):
                                lp_x = lp_cx[key][j]
                                lp_y = lp_cy[key][j]
                                list.append([lp_x, lp_y])
                            self.lp_c[key] = list                    
                    
        def get_tp(self):
                if self.basic_flag == 'on' or self.basic_flag == 'yes' or self.basic_flag == True:
                    listdir = os.listdir(self.p)
                    if ('tp_x' in listdir and 'tp_x' in listdir):
                        tp_x = {}
                        tp_y = {}
                        read_dict(self.p, 'tp_x', tp_x)
                        read_dict(self.p, 'tp_y', tp_y)
                        for key in tp_x.keys():
                            list = []
                            for j in range(len(tp_x[key])):
                                sub_list = []
                                for i in range(len(tp_x[key][j])):
                                    v = vector(tp_x[key][j][i], tp_y[key][j][i], 0)
                                    sub_list.append(v)
                                list.append(sub_list)
                            self.tp[key] = list
                
        def get_Q(self):
                if self.Q_flag == 'on' or self.Q_flag == 'yes' or self.Q_flag == True:
                    self.read_scalarlpfield('Q', self.Q)
                
        def get_phi2s(self):
                if self.phi2s_flag == 'on' or self.phi2s_flag == 'yes' or self.phi2s_flag == True:
                    self.read_scalarlpfield('phi2s', self.phi2s)

        def read_scalarlpfield(self, name, output):
                listdir = os.listdir(self.p+'/'+ str(self.t[0]))
                if name in listdir:            
                    for key in self.lp.keys():
                        output[key] = np.zeros((len(self.t), len(self.lp[key])))

                    for t in range(len(self.t)):
                        sub_dict = {}
                        read_dict(self.p+'/'+ str(self.t[t]), name, sub_dict)
                        for key in sub_dict.keys():
                            list = sub_dict[key]
                            for i in range(len(list)):                    
                                output[key][t,i] = list[i]
                        
        def get_z_tp(self):
                if self.basic_flag == 'on' or self.basic_flag == 'yes' or self.basic_flag == True:
                    self.read_scalartpfield('z_tp', self.z_tp, False, True)

        def get_he_tp(self):
                self.read_scalartpfield('he_tp', self.he_tp, False, True) 

        def get_h_tp(self, Max = False):
                if self.h_flag == 'on' or self.h_flag == 'yes' or self.h_flag == True:
                    self.read_scalartpfield('h_tp', self.h_tp, Max)               

        def get_Us_m_tp(self, Max = False):
                if self.Us_flag == 'on' or self.Us_flag == 'yes' or self.Us_flag == True:
                    self.read_scalartpfield('Us_m_tp', self.Us_m_tp, Max) 

        def get_deltah0_tp(self):
                if self.deltaz0_flag == 'on' or self.deltaz0_flag == 'yes' or self.deltaz0_flag == True:
                    self.read_scalartpfield('deltah0_tp', self.deltah0_tp) 

        def get_deltac0_tp(self):
                if self.deltaz0_flag == 'on' or self.deltaz0_flag == 'yes' or self.deltaz0_flag == True:
                    self.read_scalartpfield('deltac0_tp', self.deltac0_tp) 

        def get_h_tp_max(self):
                self.get_field_tp_max(self.h_tp, self.h_tp_max)

        def get_Us_m_tp_max(self):
                self.get_field_tp_max(self.Us_m_tp, self.Us_m_tp_max)

        def get_deltac0_tp_max(self):
                self.get_field_tp_max(self.deltac0_tp, self.deltac0_tp_max, -1)

        def get_deltah0_tp_max(self):
                self.get_field_tp_max(self.deltah0_tp, self.deltah0_tp_max, -1)

        def get_z_tp_min(self):
                self.get_field_tp_min(self.z_tp, self.z_tp_min)

        def get_field_tp_max(self, field, output, sign = 1):
                for key in field.keys():
                    field_max = np.zeros((len(self.tp[key]),1))
                    for t in range(len(self.t)):
                        for i in range(len(field_max)):
                            field_max[i,0] = max(field_max[i,0]*sign, max(np.asarray(field[key][t][i])*sign))
                    
                    output[key] = field_max                

        def get_field_tp_min(self, field, output):
                for key in field.keys():
                    field_min = np.ones((len(self.tp[key]),1))*10**6
                    for i in range(len(field_min)):
                        field_min[i,0] = min(field_min[i,0], min(field[key][i]))
                    
                    output[key] = field_min  

        def plot_h_tp_max(self,key,deltax_axis = 30,deltay_axis = 0.5):
                self.plot_lpfield_max(key, self.h_tp_max, 'h', 'm', deltax_axis, deltay_axis)

        def plot_Us_m_tp_max(self,key,deltax_axis = 30,deltay_axis = 0.5):
                self.plot_lpfield_max(key, self.Us_m_tp_max, 'Us', 'm/s', deltax_axis, deltay_axis)

        def plot_deltac0_tp_max(self,key,deltax_axis = 30,deltay_axis = 0.5):
                self.plot_lpfield_max(key, self.deltac0_tp_max, 'erosion depth', 'm', deltax_axis, deltay_axis)

        def plot_freeSurface(self,key,deltax_axis = 30,deltay_axis = 5):
                fig, ax = plt.subplots(figsize=(10, 5))
                ax.yaxis.set_major_locator(MultipleLocator(deltay_axis))
                ax.xaxis.set_major_locator(MultipleLocator(deltax_axis))
                field = self.z_tp_min[key]+self.h_tp_max[key]                                              
                plt.plot(self.lp[key],abs(field[:,0]))
                plt.plot(self.lp[key],abs(self.z_tp_min[key][:,0]))
                plt.xlim([0, self.lp[key][-1]])
                plt.grid(True)
                plt.xlabel('l (m)'); plt.ylabel('z' +' ('+ 'm'+')')

        def plot_lpfield_max(self,key, field_dict, name, units, deltax_axis, deltay_axis):
                fig, ax = plt.subplots(figsize=(10, 5))
                ax.yaxis.set_major_locator(MultipleLocator(deltay_axis))
                ax.xaxis.set_major_locator(MultipleLocator(deltax_axis))
                field = field_dict[key]
                plt.plot(self.lp[key],abs(field[:,0]), label = 'Us')                                              
#                line1, = plt.plot(self.lp[key],abs(field[:,0]), label = 'Us')
                plt.xlim([-deltax_axis*0.5, self.lp[key][-1]+deltax_axis*0.5])
                plt.ylim([-deltay_axis*0.5,  1.05*max(abs(field[:,0]))])
                plt.grid(True)
                plt.xlabel('l (m)', fontsize = 14); plt.ylabel(name +' ('+ units+')', fontsize = 14)
                
                plt.plot([self.lp[key][139],self.lp[key][139]],[-10,15], color = 'black', linestyle = 'dashed', linewidth = 1.5)
                plt.plot([self.lp[key][280],self.lp[key][280]],[-10,15], color = 'black', linestyle = 'dashed', linewidth = 1.5)
                plt.plot([self.lp[key][159],self.lp[key][159]],[-10,15], color = 'black', linestyle = 'dashed', linewidth = 1.5)
                
                line2, = plt.plot([self.lp[key][139],self.lp[key][280]],[5.64,5.64], color = 'brown', linestyle = 'dashed', linewidth = 1.5, label = 'prom1')
                line3, = plt.plot([self.lp[key][159],self.lp[key][280]],[5.36,5.36], color = 'green', linestyle = 'dashed', linewidth = 1.5, label = 'prom2')
                
                text(self.lp[key][141], 1, "check dam 28", rotation=90, verticalalignment='bottom')
                text(self.lp[key][282], 1, "check dam 29", rotation=90, verticalalignment='bottom')
                            
                plt.legend(handler_map= {})
                    
        def read_scalartpfield(self, name, output, Max = False,  button = False):
                if button == False:
                    listdir = os.listdir(self.p+'/'+ str(self.t[0]))
                    if name in listdir:            
                        for key in self.lp.keys():
                            output[key] = []                               
    
                        for t in range(len(self.t)):
                            sub_dict = {}
                            read_dict(self.p+'/'+ str(self.t[t]), name, sub_dict)
                            for key in sub_dict.keys():
                                list = sub_dict[key]
                                if Max == True:
                                    for i in range(len(list)):
                                        list[i] = max(list[i])
                                output[key].append(list)
                else:
                    listdir = os.listdir(self.p)
                    if name in listdir:            
                        for key in self.lp.keys():
                            output[key] = []                               
    
                        sub_dict = {}
                        read_dict(self.p, name, sub_dict)
                        for key in sub_dict.keys():
                            list = sub_dict[key]
                            output[key] = list

        def plot_M_net(self, save = False, clip = False, ymin = 0, ymax = 0):
                if self.tps == {}:
                    list = []
                    get_input(self.p+'/transportProperties',list)    
                    read_dictionary(list,self.tps)
                rho_b = self.tps['rho_b']['value']
                fig, ax = plt.subplots(figsize=(5, 10))
                line1, = plt.plot(self.t ,self.rF_M, label = 'input mass')
                line2, = plt.plot(self.t ,self.M[:,0], label = 'total mass')
                line3, = plt.plot(self.t ,-self.Vsed[:,0]*rho_b, label = 'estimated incorporated mass')
                line4, = plt.plot(self.t ,self.M[:,0]-self.rF_M, label = 'incorporated mass')

                plt.xlim([0, self.t[-1]])
                if clip == True:
                    plt.ylim([ymin,  ymax])
                plt.grid(True)
                plt.xlabel('t (s)'); plt.ylabel('m (kg)')
                
                plt.legend(handler_map= {})

                if save == True:
                    path = self.p+'/images'
                    fig.savefig(path+'/'+'M_net')
                    plt.close(fig)            

        def plot_V_net(self, save = False, clip = False, ymin = 0, ymax = 0):
                fig, ax = plt.subplots(figsize=(5, 10))
                line1, = plt.plot(self.t ,self.rF_V, label = 'input volume')
                line2, = plt.plot(self.t ,self.V[:,0], label = 'total volume')
                line3, = plt.plot(self.t ,-self.Vsed[:,0], label = 'estimated incorporated volume')
                line4, = plt.plot(self.t ,self.V[:,0]-self.rF_V, label = 'incorporated volume')

                plt.xlim([0, self.t[-1]])
                if clip == True:
                    plt.ylim([ymin,  ymax])
                plt.grid(True)
                plt.xlabel('t (s)'); plt.ylabel('V (m³)')
                
                plt.legend(handler_map= {})

                if save == True:
                    path = self.p+'/images'
                    fig.savefig(path+'/'+'V_net')
                    plt.close(fig) 

        def plot_longitudinal_profiles(self):
                figure = plt.figure(figsize = (5,10))
                plt.grid(True)
                plt.title('Longitudinal profiles',fontsize = 17); plt.xlabel('x (m)'); plt.ylabel('y (m)')
                for key in self.lp_c.keys():               
                    coords = np.zeros((len(self.lp_c[key]),2))
                    for i in range(len(coords)):
                        coords[i,0] = self.lp_c[key][i][0]
                        coords[i,1] = self.lp_c[key][i][1]
                    plt.plot(coords[:,0],coords[:,1])

        def plot_zylongitudinal_profiles(self, entrainmentZones = False):
                figure = plt.figure(figsize = (5,10))
                plt.grid(True)
                z = self.z.transpose()
                plt.contourf(self.x,self.y,z,cmap = plt.get_cmap('hot'))
                plt.colorbar()
                plt.title('Longitudinal profiles',fontsize = 17); plt.xlabel('x (m)'); plt.ylabel('y (m)')
                for key in self.lp_c.keys():               
                    coords = np.zeros((len(self.lp_c[key]),2))
                    for i in range(len(coords)):
                        coords[i,0] = self.lp_c[key][i][0]
                        coords[i,1] = self.lp_c[key][i][1]
                    line1, = plt.plot(coords[:,0],coords[:,1], lw = 5, label = 'longitudinal profile')
                    
                if entrainmentZones == True:
                    if self.tps == {}:
                        list = []
                        get_input(self.p+'/transportProperties',list)    
                        read_dictionary(list,self.tps)
                    eZlist = []
                    eM = self.tps['entrainmentModel']
                    for element in self.tps[eM+'Coeffs']:
                        if type(element) == dict:
                            eZlist.append(element)
               
                    for i in range(len(eZlist)):
                        off = eZlist[i]['offset'][0][:-1]
                        polygon = eZlist[i]['vertices']
                        rectangle = np.zeros((len(polygon)+1,2))
                        
                        for j in range(len(polygon)):
                            rectangle[j,0] = polygon[j][0]-off[0]
                            rectangle[j,1] = polygon[j][1]-off[1]
                            
                        rectangle[-1,0] = rectangle[0,0]
                        rectangle[-1,1] = rectangle[0,1] 
                            
                        line2, = plt.plot(rectangle[:,0], rectangle[:,1], lw = 5, color='black', label = 'entrainment zone '+ str(i+1))
                        
                    self.tps = {}
                                                
                plt.legend(handler_map= {}) 
                                       
        def plot_transversal_profiles(self):
                figure = plt.figure(figsize = (8,20))
                plt.grid(True)
                plt.title('Transversal  Profiles',fontsize = 17); plt.xlabel('x (m)'); plt.ylabel('y (m)')
                for key in self.lp_c.keys():
                    coords = np.zeros((len(self.lp_c[key]),2))
                    for i in range(len(coords)):
                        coords[i,0] = self.lp_c[key][i][0]
                        coords[i,1] = self.lp_c[key][i][1]
                    plt.plot(coords[:,0],coords[:,1])
                    
                    for i in range(len(self.tp[key])):
                        vertexes = self.tp[key][i]
                        plt.plot([vertexes[0].x, vertexes[-1].x] ,[vertexes[0].y, vertexes[-1].y])

        def plot_zytransversal_profiles(self):
                figure = plt.figure(figsize = (8,20))
                plt.grid(True)
                z = self.z.transpose()
                plt.contourf(self.x,self.y,z,cmap = plt.get_cmap('hot'))
                plt.colorbar()
                plt.title('Transversal  Profiles',fontsize = 17); plt.xlabel('x (m)'); plt.ylabel('y (m)')
                for key in self.lp_c.keys():
                    coords = np.zeros((len(self.lp_c[key]),2))
                    for i in range(len(coords)):
                        coords[i,0] = self.lp_c[key][i][0]
                        coords[i,1] = self.lp_c[key][i][1]
                    plt.plot(coords[:,0],coords[:,1], lw = 5)
                    
                    for i in range(len(self.tp[key])):
                        vertexes = self.tp[key][i]
                        plt.plot([vertexes[0].x, vertexes[-1].x] ,[vertexes[0].y, vertexes[-1].y])

        def plot_transversal_profile(self, key, list, limit = True, entrainmentZones = False):
                figure = plt.figure(figsize = (4,10))
                plt.grid(True)

                coords = np.zeros((len(self.lp_c[key]),2))
                for i in range(len(coords)):
                    coords[i,0] = self.lp_c[key][i][0]
                    coords[i,1] = self.lp_c[key][i][1]
                line1, = plt.plot(coords[:,0],coords[:,1], lw = 5, label = 'longitudinal profile')
                if limit == True:
                    plt.xlim([self.x[0], self.x[-1]])
                    plt.ylim([self.y[0], self.y[-1]])

                names = ''                
                for i in range(len(list)):
                    names += str(list[i])+' '
                    vertexes = self.tp[key][list[i]]
                    plt.plot([vertexes[0].x, vertexes[-1].x] ,[vertexes[0].y, vertexes[-1].y])

                plt.title('Transversal  Profile n = '+ names,fontsize = 17); plt.xlabel('x (m)'); plt.ylabel('y (m)')

                if entrainmentZones == True:
                    if self.tps == {}:
                        list = []
                        get_input(self.p+'/transportProperties',list)    
                        read_dictionary(list,self.tps)
                    eZlist = []
                    eM = self.tps['entrainmentModel']
                    for element in self.tps[eM+'Coeffs']['entrainmentZones']:
                        if type(element) == dict:
                            eZlist.append(element)                    
                                    
                    for i in range(len(eZlist)):
                        off = eZlist[i]['offset'][0][:-1]
                        polygon = eZlist[i]['vertices']
                        rectangle = np.zeros((len(polygon)+1,2))
                        
                        for j in range(len(polygon)):
                            rectangle[j,0] = polygon[j][0]-off[0]
                            rectangle[j,1] = polygon[j][1]-off[1]
                            
                        rectangle[-1,0] = rectangle[0,0]
                        rectangle[-1,1] = rectangle[0,1] 
                            
                        line2, = plt.plot(rectangle[:,0], rectangle[:,1], lw = 5, color='black', label = 'entrainment zone '+ str(i+1))
                        
                    self.tps = {}
                                               
                plt.legend(handler_map= {})

        def plot_zytransversal_profile(self, key_list, list, entrainmentZones = False, save = False, inv = False, lg_loc = 'lower left'):
                if inv == False:
                    figure = plt.figure(figsize = (6,12))
                    z = self.z.transpose()
                    plt.contourf(self.x,self.y,z,cmap = plt.get_cmap('hot'))
                    plt.xlabel('x (m)', fontsize = 14)
                    plt.ylabel('y (m)', fontsize = 14)
                else:
                    figure, ax = plt.subplots(figsize = (14,4))
                    z = self.z
                    plt.contourf(self.y,self.x,z,cmap = plt.get_cmap('hot'))
                    plt.ylabel('x (m)', fontsize = 14)
                    plt.xlabel('y (m)', fontsize = 14)
                    plt.ylim([self.x[-1],self.x[0]])
                    ax.xaxis.set_ticks_position('top')
                    ax.xaxis.set_label_position('top')
                plt.colorbar(label='z (m)')
                plt.grid(True)

                for k in range(len(key_list)):
                    key = key_list[k]
                    coords = np.zeros((len(self.lp_c[key]),2))
                    for i in range(len(coords)):
                        coords[i,0] = self.lp_c[key][i][0]
                        coords[i,1] = self.lp_c[key][i][1]
                    if inv == False:
                        line1, = plt.plot(coords[:,0],coords[:,1], lw = 5, label = 'LP '+str(k+1))
                    else:
                        line1, = plt.plot(coords[:,1],coords[:,0], lw = 5, label = 'LP '+str(k+1))

                    for i in range(len(list[k])):
                        vertexes = self.tp[key][list[k][i]]
                        if inv == False:
                            line2, = plt.plot([vertexes[0].x, vertexes[-1].x], [vertexes[0].y, vertexes[-1].y], lw = 3, label = '  TP '+str(list[k][i]))
                        else:
                            line2, = plt.plot([vertexes[0].y, vertexes[-1].y], [vertexes[0].x, vertexes[-1].x], lw = 3, label = '  TP '+str(list[k][i]))

                if entrainmentZones == True:
                    if self.tps == {}:
                        list = []
                        get_input(self.p+'/transportProperties',list)    
                        read_dictionary(list,self.tps)
                    eZlist = []
                    eM = self.tps['entrainmentModel']
                    for element in self.tps[eM+'Coeffs']['entrainmentZones']:
                        if type(element) == dict:
                            eZlist.append(element)                    
                    
                    for i in range(len(eZlist)):
                        off = eZlist[i]['offset'][0][:-1]
                        polygon = eZlist[i]['vertices']
                        rectangle = np.zeros((len(polygon)+1,2))
                        
                        for j in range(len(polygon)):
                            rectangle[j,0] = polygon[j][0]-off[0]
                            rectangle[j,1] = polygon[j][1]-off[1]
                            
                        rectangle[-1,0] = rectangle[0,0]
                        rectangle[-1,1] = rectangle[0,1] 
                        
                        if inv == False:
                            line3, = plt.plot(rectangle[:,0], rectangle[:,1], lw = 5, color='black', label = 'entrainment zone')
                        else:
                            line3, = plt.plot(rectangle[:,1], rectangle[:,0], lw = 5, color='black', label = 'entrainment zone')
                            
                    self.tps = {}
                                          
                plt.legend(handler_map= {}, loc=lg_loc)
                
                if save == True:
                    path = self.p+'/images'
                    figure.savefig(path+'/'+'zplot')
                    plt.close(figure)

        def plot_imageytransversal_profile(self, im_name, key_list, list, off_x = 0, off_y = 0, figsize_x = 8, figsize_y = 8, entrainmentZones = False, save = False, inv = False, lg_loc = 'lower left'):
                im = plt.imread(self.p+'/'+im_name)
                fig, ax = plt.subplots(figsize=(figsize_x, figsize_y))
                extent = [self.x[0]+off_x,self.x[-1]+off_x,self.y[0]+off_y,self.y[-1]+off_y]
                ax.imshow(im,extent = extent, aspect='auto')
                plt.grid()
                plt.tick_params(labelleft = False, labelright = True)

                x, y, arrow_length = 0.1, 0.95, 0.075
                ax.annotate('N', xy=(x, y), xytext=(x, y-arrow_length),
                    arrowprops=dict(facecolor='black', width=5, headwidth=15),
                    ha='center', va='center', fontsize=20,
                    xycoords=ax.transAxes)

                for k in range(len(key_list)):
                    key = key_list[k]
                    coords = np.zeros((len(self.lp_c[key]),2))
                    for i in range(len(coords)):
                        coords[i,0] = self.lp_c[key][i][0]+off_x
                        coords[i,1] = self.lp_c[key][i][1]+off_y
                    if inv == False:
#                        line1, = plt.plot(coords[:,0],coords[:,1], lw = 5, label = 'LP '+str(k+1))
                        line1, = plt.plot(coords[:,0],coords[:,1], lw = 5, label = 'Illgraben')
                    else:
                        line1, = plt.plot(coords[:,1],coords[:,0], lw = 5, label = 'LP '+str(k+1))

                    for i in range(len(list[k])):
                        vertexes = self.tp[key][list[k][i]]
                        if inv == False:
                            line2, = plt.plot([vertexes[0].x+off_x, vertexes[-1].x+off_x], [vertexes[0].y+off_y, vertexes[-1].y+off_y], lw = 3, label = '  TP '+str(list[k][i]))
                            if list[k][i] == 140:
                                line2, = plt.plot([vertexes[0].x+off_x, vertexes[-1].x+off_x], [vertexes[0].y+off_y, vertexes[-1].y+off_y], lw = 3, label = 'Check Dam 28')
                            elif list[k][i] == 280:
                                line2, = plt.plot([vertexes[0].x+off_x, vertexes[-1].x+off_x], [vertexes[0].y+off_y, vertexes[-1].y+off_y], lw = 3, label = 'Check Dam 29')
                        else:
                            line2, = plt.plot([vertexes[0].y+off_y, vertexes[-1].y+off_y], [vertexes[0].x+off_x, vertexes[-1].x+off_x], lw = 3, label = '  TP '+str(list[k][i]))

                if entrainmentZones == True:
                    if self.tps == {}:
                        list = []
                        get_input(self.p+'/transportProperties',list)    
                        read_dictionary(list,self.tps)
                    eZlist = []
                    eM = self.tps['entrainmentModel']
                    for element in self.tps[eM+'Coeffs']['entrainmentZones']:
                        if type(element) == dict:
                            eZlist.append(element)                    
                    
                    for i in range(len(eZlist)):
                        off = eZlist[i]['offset'][0][:-1]
                        polygon = eZlist[i]['vertices']
                        rectangle = np.zeros((len(polygon)+1,2))
                        
                        for j in range(len(polygon)):
                            rectangle[j,0] = polygon[j][0]-off[0]+off_x
                            rectangle[j,1] = polygon[j][1]-off[1]+off_y
                            
                        rectangle[-1,0] = rectangle[0,0]
                        rectangle[-1,1] = rectangle[0,1] 
                        
                        if inv == False:
#                            line3, = plt.plot(rectangle[:,0], rectangle[:,1], lw = 5, color='black', label = 'entrainment zone')
                            line3, = plt.plot(rectangle[:,0], rectangle[:,1], lw = 5, color='black', label = 'zona de erosión')
                        else:
                            line3, = plt.plot(rectangle[:,1], rectangle[:,0], lw = 5, color='black', label = 'entrainment zone')
                            
                    self.tps = {}
                                          
                plt.legend(handler_map= {}, loc=lg_loc)
                
                if save == True:
                    path = self.p+'/images'
                    fig.savefig(path+'/'+'imageplot')
                    plt.close(fig)

        def plot_hylongitudinal_profiles(self, t, entrainmentZones = False):
                figure = plt.figure(figsize = (5,10))
                plt.grid(True)
                j = self.t.index(t)
                field_t = self.h[j,:,:].transpose()
                plt.contourf(self.x,self.y,field_t,cmap = plt.get_cmap('hot'))
                plt.colorbar()
                plt.title('Longitudinal profiles',fontsize = 17); plt.xlabel('x (m)'); plt.ylabel('y (m)')
                for key in self.lp_c.keys():               
                    coords = np.zeros((len(self.lp_c[key]),2))
                    for i in range(len(coords)):
                        coords[i,0] = self.lp_c[key][i][0]
                        coords[i,1] = self.lp_c[key][i][1]
                    line1, = plt.plot(coords[:,0],coords[:,1], lw = 5, label = 'longitudinal profile')
                    
                if entrainmentZones == True:
                    if self.tps == {}:
                        list = []
                        get_input(self.p+'/transportProperties',list)    
                        read_dictionary(list,self.tps)
                    eZlist = []
                    eM = self.tps['entrainmentModel']
                    for element in self.tps[eM+'Coeffs']['entrainmentZones']:
                        if type(element) == dict:
                            eZlist.append(element)                    
                    
                    for i in range(len(eZlist)):
                        off = eZlist[i]['offset'][0][:-1]
                        polygon = eZlist[i]['vertices']
                        rectangle = np.zeros((len(polygon)+1,2))
                        
                        for j in range(len(polygon)):
                            rectangle[j,0] = polygon[j][0]-off[0]
                            rectangle[j,1] = polygon[j][1]-off[1]
                            
                        rectangle[-1,0] = rectangle[0,0]
                        rectangle[-1,1] = rectangle[0,1] 
                        
                        line2, = plt.plot(rectangle[:,0], rectangle[:,1], lw = 5, color='black', label = 'entrainment zone')
                            
                    self.tps = {}
                                          
                plt.legend(handler_map= {})

        def plot_M(self,firstvalue = 0, save = False, figsize_x = 5, figsize_y = 10):
                self.plot_timefield(self.M, 'M', 'kg', firstvalue, save, figsize_x, figsize_y)

        def plot_V(self,firstvalue = 0, save = False, figsize_x = 5, figsize_y = 10):
                self.plot_timefield(self.V, 'V', 'm³', firstvalue, save, figsize_x, figsize_y)
                
        def plot_Vsed(self,firstvalue = 0, save = False, figsize_x = 5, figsize_y = 10):
                self.plot_timefield(self.Vsed, 'Vsed', 'm³', firstvalue, save, figsize_x, figsize_y)

        def plot_Cv_avrg(self,firstvalue = 0, save = False, figsize_x = 5, figsize_y = 10, clip = False, ymin = 0, ymax = 0):
                self.plot_timefield(self.Cv_avrg, 'Cv', '-', firstvalue, save, figsize_x, figsize_y, clip, ymin, ymax)

        def plot_rcg_x(self,firstvalue = 0, save = False, figsize_x = 5, figsize_y = 10):
                self.plot_timefield(self.rcg[:,0], 'rcg_x', 'm', firstvalue, save, figsize_x, figsize_y, True, self.x[0], self.x[-1])

        def plot_rcg_y(self,firstvalue = 0, save = False, figsize_x = 5, figsize_y = 10):
                self.plot_timefield(self.rcg[:,1], 'rcg_y', 'm', firstvalue, save, figsize_x, figsize_y, True, self.y[0], self.y[-1])

        def plot_rcg_z(self,firstvalue = 0, save = False, figsize_x = 5, figsize_y = 10):
                self.plot_timefield(self.rcg[:,2], 'rcg_z', 'm', firstvalue, save, figsize_x, figsize_y)                
                
        def plot_timefield(self, field, name, units, firstvalue, save, figsize_x, figsize_y, clip = False, ymin = 0, ymax = 0):
                fig, ax = plt.subplots(figsize=(figsize_x, figsize_y))
                plt.plot(self.t[firstvalue:] ,field[firstvalue:])
                plt.xlim([0, self.t[-1]])
                if clip == True:
                    plt.ylim([ymin,  ymax])
                plt.grid(True)
                plt.xlabel('t (s)'); plt.ylabel(name +' ('+ units+')')

                if save == True:
                    path = self.p+'/images'
                    fig.savefig(path+'/'+name)
                    plt.close(fig)

        def plot_field(self,t,field, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                figure = plt.figure(figsize = (5,10))
                plt.grid(True)
                if t != -1:
                    j = self.t.index(t)
                    field_t = field[j,:,:].transpose()
                    if clip == False:
                        x = self.x
                        y = self.y
                    elif clip == True:
                        imin = int((xmin-self.x[0])/(self.x[1]-self.x[0]))
                        imax = int((xmax-self.x[0])/(self.x[1]-self.x[0]))+1
                        jmin = int((ymin-self.y[0])/(self.y[1]-self.y[0]))
                        jmax = int((ymax-self.y[0])/(self.y[1]-self.y[0]))+1
                        x = self.x[imin:imax]
                        y = self.y[jmin:jmax]
                        field_t = field_t[jmin:jmax, imin:imax]
                    if lim == True:
                        for i in range(len(x)):
                            for j in range(len(y)):
                                field_t[j,i] = max(min(field_t[j,i], lim_max), lim_min)
                    plt.contourf(x,y,field_t,cmap = plt.get_cmap('hot'))
                    if lim == True: ##It can be improved //AG
                        rg = np.arange(lim_min, lim_max+0.1, 0.1)
                        plt.colorbar(ticks=rg, label='digit value')
                        plt.clim(vmin = lim_min, vmax = lim_max)
                    else:
                        plt.colorbar(label='digit value')
                    tit = 't = '+ str(t) +'s'
                    plt.title(tit,fontsize = 17); plt.xlabel('x (m)'); plt.ylabel('y (m)')
                else:
                    field_t = field.transpose()
                    plt.contourf(self.x,self.y,field_t,cmap = plt.get_cmap('hot'))
                    plt.xlabel('x (m)'); plt.ylabel('y (m)')
                    plt.colorbar()
                                        
        def plot_field_video(self, field, name, clean = True, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                j1='imagen00'
                j2='imagen0'
                j3='imagen'
                
                make_dir(self.p, 'images')
                path = self.p+'/images'
                clean_dir(path, name)
                make_dir(path, name)
                
                for t in range(len(self.t)):
                    figure = plt.figure(figsize = (5,10))
                    plt.grid(True)
                    field_t = field[t,:,:].transpose()
                    if clip == False:
                        x = self.x
                        y = self.y
                    elif clip == True:
                        imin = int((xmin-self.x[0])/(self.x[1]-self.x[0]))
                        imax = int((xmax-self.x[0])/(self.x[1]-self.x[0]))+1
                        jmin = int((ymin-self.y[0])/(self.y[1]-self.y[0]))
                        jmax = int((ymax-self.y[0])/(self.y[1]-self.y[0]))+1
                        x = self.x[imin:imax]
                        y = self.y[jmin:jmax]
                        field_t = field_t[jmin:jmax, imin:imax]
                    if lim == True:
                        for i in range(len(x)):
                            for j in range(len(y)):
                                field_t[j,i] = max(min(field_t[j,i], lim_max), lim_min)
                    plt.contourf(x,y,field_t,cmap = plt.get_cmap('hot'))
                    if lim == True: ##It can be improved //AG
                        rg = np.arange(lim_min, lim_max+0.1, 0.1)
                        plt.colorbar(ticks=rg, label='digit value')
                        plt.clim(vmin = lim_min, vmax = lim_max)
                    else:
                        plt.colorbar(label='digit value')
                    tit = 't = '+ str(self.t[t]) +'s'
                    plt.title(tit,fontsize = 17); plt.xlabel('x (m)'); plt.ylabel('y (m)')
                   
                    if t>=10 and t<100:
                        d=j2+str(t)
                    elif t<10:
                        d=j1+str(t)
                    else:
                        d=j3+str(t)
                        
                    figure.savefig(self.p+'/images/'+name+'/'+d)
                    plt.close(figure)
                    
                os.chdir(self.p+'/images/'+name)
                os.system("ffmpeg -framerate 3 -i imagen%03d.png {}.mp4".format(name))
                
                if clean == True:
                    shutil.copy(self.p+'/images/'+name+'/'+name+'.mp4', self.p+'/images/'+name+'.mp4')
                    clean_dir(path, name)

        def plot_h_video(self, clean = True, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field_video(self.h, 'h', clean, lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)
                
        def plot_pb_video(self, clean = True, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field_video(self.pb, 'pb', clean, lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)

        def plot_Cv_video(self, clean = True, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field_video(self.Cv, 'Cv', clean, lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)

        def plot_deltah0_video(self, clean = True, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field_video(self.deltah0,'deltah0', clean, lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)

        def plot_deltac0_video(self, clean = True, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field_video(self.deltac0,'deltac0', clean, lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)

        def plot_Us_m_video(self, clean = True, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field_video(self.Us_m, 'Us_m', clean, lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)
                
        def plot_tau_m_video(self, clean = True, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field_video(self.tau_m, 'tau_m', clean, lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)

        def plot_Sm_video(self, clean = True, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field_video(self.Sm, 'Sm', clean, lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)

        def plot_rho_video(self, clean = True, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field_video(self.rho, 'rho', clean, lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)

        def plot_h(self,t, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field(t,self.h, lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)
                
        def plot_Us_x(self,t, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field(t,self.Us[:,:,:,0], lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)
                
        def plot_Us_y(self,t, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field(t,self.Us[:,:,:,1], lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)
                
        def plot_Us_z(self,t, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field(t,self.Us[:,:,:,2], lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)

        def plot_Us_m(self,t, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field(t,self.Us_m, lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)
                                
        def plot_pb(self,t, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field(t,self.pb, lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)
        
        def plot_tau_x(self,t, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field(t,self.tau[:,:,:,0], lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)
                
        def plot_tau_y(self,t, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field(t,self.tau[:,:,:,1], lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)
                
        def plot_tau_z(self,t, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field(t,self.tau[:,:,:,2], lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)

        def plot_tau_m(self,t, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field(t,self.tau_m, lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)
                
        def plot_Cv(self,t, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field(t,self.Cv, lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)

        def plot_deltah0(self,t, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field(t,self.deltah0, lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)

        def plot_deltac0(self, t, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field(t,self.deltac0, lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)

        def plot_Sm(self,t, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field(t,self.Sm, lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)

        def plot_rho(self,t, lim = False, lim_min = 0, lim_max = 1, clip = False, xmin = 0, xmax = 0, ymin = 0, ymax = 0):
                self.plot_field(t,self.rho, lim, lim_min, lim_max, clip, xmin, xmax, ymin, ymax)
                                                             
        def plot_z(self):
                self.plot_field(-1, self.z)

        def plot_he(self):
                self.plot_field(-1, self.he)
                                
        def plot_h_tp(self, key, t, index, xmin = -1, xmax = -1):
                j = self.t.index(t)
                h_tp = np.array(self.h_tp[key][j][index])
                he_tp = np.array(self.he_tp[key][index])
                z_tp = np.array(self.z_tp[key][index])

                dists = [0]*len(self.tp[key][index])
                dist_max = distxy(self.tp[key][index][0], self.tp[key][index][-1])
                
                for i in range(len(dists)):
                    dists[i] = distxy(self.tp[key][index][0], self.tp[key][index][i])-dist_max/2

                if xmin != -1:
                    imin = int((xmin-dists[0])/dist_max*len(dists))
                else:
                    imin = 0
                if xmax != -1:
                    imax = int((xmax-dists[0])/dist_max*len(dists))+1
                else:
                    imax = len(dists)

                figure = plt.figure(figsize = (12,5))
                plt.grid(True)
                tit = 't = '+ str(t) +'s'
                plt.title(tit,fontsize = 17); plt.xlabel('x (m)'); plt.ylabel('z (m)')
                
                line1, = plt.plot(dists[imin:imax], z_tp[imin:imax], 'orange', label = 'initial bottom') 
                line2, = plt.plot(dists[imin:imax], (z_tp-he_tp)[imin:imax], 'y', label = 'initial erodible layer')
                                
                if self.deltac0_tp != {}:
                    deltac0_tp = np.array(self.deltac0_tp[key][j][index])
                    line3, = plt.plot(dists[imin:imax], (h_tp+z_tp+deltac0_tp)[imin:imax], 'b', label = 'flow height')     
                    line4, = plt.plot(dists[imin:imax], (deltac0_tp+z_tp)[imin:imax], 'r', label = 'actual bottom')                
                elif self.deltah0_tp != {}:
                    deltac0_tp = np.array(self.deltac0_tp[key][j][index])
                    line3, = plt.plot(dists[imin:imax], (h_tp+z_tp)[imin:imax], 'b', label = 'flow height')     
                    line4, = plt.plot(dists[imin:imax], (deltac0_tp+z_tp)[imin:imax], 'r', label = 'actual erodible layer')                                
                else:
                    line3, = plt.plot(dists[imin:imax], (h_tp+z_tp)[imin:imax], 'b', label = 'flow height')                 
                                                                    
                plt.legend(handler_map= {})                  

        def plot_h_tp_video(self, key, index, clean = True, xmin = -1, xmax = -1):
                j1='imagen00'
                j2='imagen0'
                j3='imagen'
                
                make_dir(self.p, 'images')
                path = self.p+'/images'
                dir = 'index'+str(index)
                clean_dir(path, dir)
                make_dir(path, dir)
                z_tp = np.array(self.z_tp[key][index])
                he_tp = np.array(self.he_tp[key][index])

                dists = [0]*len(self.tp[key][index])
                dist_max = distxy(self.tp[key][index][0], self.tp[key][index][-1])

                for i in range(len(dists)):
                    dists[i] = distxy(self.tp[key][index][0], self.tp[key][index][i])-dist_max/2

                if xmin != -1:
                    imin = int((xmin-dists[0])/dist_max*len(dists))
                else:
                    imin = 0
                if xmax != -1:
                    imax = int((xmax-dists[0])/dist_max*len(dists))+1
                else:
                    imax = len(dists)

                if self.deltac0_tp != {}:
                    deltac0_tp = np.array(self.deltac0_tp[key][-1][index])
                else:
                    deltac0_tp = z_tp*0
                    
                max_z = max((z_tp+deltac0_tp)[imin:imax])+0.2
                min_z = min(min((z_tp+deltac0_tp)[imin:imax]),min((z_tp-he_tp)[imin:imax]))-0.2
                
                for t in range(len(self.t)):
                    figure = plt.figure(figsize = (12,5))
                    plt.grid(True)
                    tit = 't = '+ str(self.t[t]) +'s'
                    plt.title(tit,fontsize = 17)
                    plt.xlabel('x (m)'); plt.ylabel('z (m)')
                    plt.ylim([min_z, max_z])
                    
                    h_tp = self.h_tp[key][t][index]

                    line1, = plt.plot(dists[imin:imax], z_tp[imin:imax], 'orange', label = 'initial bottom') 
                    line2, = plt.plot(dists[imin:imax], (z_tp-he_tp)[imin:imax], 'y', label = 'initial erodible layer')
                    
                    if self.deltac0_tp != {}:
                        deltac0_tp = np.array(self.deltac0_tp[key][t][index])
                        line3, = plt.plot(dists[imin:imax], (h_tp+z_tp+deltac0_tp)[imin:imax], 'b', label = 'flow height')     
                        line4, = plt.plot(dists[imin:imax], (deltac0_tp + z_tp)[imin:imax], 'r', label = 'actual bottom')                    
                    elif self.deltah0_tp != {}:
                        deltah0_tp = np.array(self.deltah0_tp[key][t][index])
                        line3, = plt.plot(dists[imin:imax], (h_tp+z_tp)[imin:imax], 'b', label = 'flow height')     
                        line4, = plt.plot(dists[imin:imax], (deltah0_tp + z_tp)[imin:imax], 'r', label = 'actual erodible layer')                                        
                    else:
                        line3, = plt.plot(dists[imin:imax], (h_tp+z_tp)[imin:imax], 'b', label = 'flow height')     
                                                    
                    plt.legend(handler_map= {})
                    
                    if t>=10 and t<100:
                        d=j2+str(t)
                    elif t<10:
                        d=j1+str(t)
                    else:
                        d=j3+str(t)
                        
                    figure.savefig(path+'/'+dir+'/'+d)
                    plt.close(figure)

                os.chdir(self.p+'/images/'+dir)
                os.system("ffmpeg -framerate 3 -i imagen%03d.png {}.mp4".format('h_tp_'+str(index)))

                if clean == True:
                    shutil.copy(self.p+'/images/'+dir+'/'+'h_tp_'+str(index)+'.mp4', self.p+'/images/'+'h_tp_'+str(index)+'.mp4')
                    clean_dir(path, dir)

        def plot_Q_tp(self,key_list,index,deltax_axis = 20,deltay_axis = 20,save = False):
                self.plot_lpfield_tp(key_list,index,self.Q,'Q','m³/s',deltax_axis,deltay_axis,save)

        def plot_phi2s_tp(self,key_list,index,deltax_axis = 20,deltay_axis = 20,save = False):
                self.plot_lpfield_tp(key_list,index,self.phi2s,'\u03C1'+ 'Q', 'kg/s',deltax_axis,deltay_axis,save)

        def plot_lpfield_tp(self, key_list, index, field_dict, name, units, deltax_axis, deltay_axis,save):
                fig, ax = plt.subplots(figsize=(10, 5))
                ax.yaxis.set_major_locator(MultipleLocator(deltay_axis))
                ax.xaxis.set_major_locator(MultipleLocator(deltax_axis))
                field = np.zeros((len(self.t),1))
                for key in key_list:
                    if key != key_list[0]:
                        if self.lp_c[key_list[0]][1:-1][index] != self.lp_c[key][1:-1][index]:
                            field[:,0] += field_dict[key][:,index]
                    else:
                        field[:,0] += field_dict[key][:,index]                                                
                plt.plot(self.t ,abs(field[:,0]))
                plt.xlim([0, self.t[-1]])
                plt.ylim([0,  1.05*max(abs(field[:,0]))])
                plt.grid(True)
                plt.title('index = '+str(index),fontsize = 17); plt.xlabel('t (s)'); plt.ylabel(name +' ('+ units+')')

                if save == True:
                    path = self.p+'/images'
                    fig.savefig(path+'/'+name+'_tp_time_index_'+str(index))
                    plt.close(fig)                
                
        def plot_phi2s(self,t, key_list,deltax_axis = 10,deltay_axis = 20):
                self.plot_lpfield(t, key_list, self.phi2s, '\u03C1'+ 'Q', 'kg/s', deltax_axis, deltay_axis)

        def plot_Q(self,t,key_list,deltax_axis = 10,deltay_axis = 20):
                self.plot_lpfield(t, key_list, self.Q, 'Q', 'm³/s', deltax_axis, deltay_axis)

        def plot_lpfield(self,t,key_list, field_dict, name, units, deltax_axis, deltay_axis):
                fig, ax = plt.subplots(figsize=(10, 5))
                j = self.t.index(t)
                ax.yaxis.set_major_locator(MultipleLocator(deltay_axis))
                ax.xaxis.set_major_locator(MultipleLocator(deltax_axis))
                field = np.zeros((len(self.lp_c[key_list[0]][1:-1]),1))
                for key in key_list:
                    for i in range(len(field)):
                        if key != key_list[0]:
                            if self.lp_c[key_list[0]][1:-1][i] != self.lp_c[key][1:-1][i]:
                                field[i,0] += field_dict[key][j,i]
                        else:
                            field[i,0] += field_dict[key][j,i]                                                 
                plt.plot(self.lp[key_list[0]],abs(field[:,0]))
                plt.xlim([0, self.lp[key_list[0]][-1]])
                plt.ylim([0,  1.05*max(abs(field[:,0]))])
                plt.grid(True)
                plt.title('t = '+str(t)+ 's',fontsize = 17); plt.xlabel('l (m)'); plt.ylabel(name +' ('+ units+')')

        def plot_phi2s_video(self,key_list,deltax_axis = 10,deltay_axis = 20, clean = True):
                self.plot_lpfield_video(key_list, self.phi2s, '\u03C1'+ 'Q', 'kg/s', deltax_axis, deltay_axis, clean)

        def plot_Q_video(self,key_list,deltax_axis = 10,deltay_axis = 20, clean = True):
                self.plot_lpfield_video(key_list, self.Q, 'Q', 'm³/s', deltax_axis, deltay_axis, clean)
 
        def plot_lpfield_video(self, key_list, field_dict, name, units, deltax_axis, deltay_axis, clean):
                j1='imagen00'
                j2='imagen0'
                j3='imagen'
                
                make_dir(self.p, 'images')
                path = self.p+'/images'
                clean_dir(path, name)
                make_dir(path, name)
                
                field = np.zeros((len(self.t),len(self.lp[key_list[0]])))

                for key in key_list:
                    for i in range(len(self.lp[key_list[0]])):
                        if key != key_list[0]:
                            if self.lp_c[key_list[0]][1:-1][i] != self.lp_c[key][1:-1][i]:
                                field[:,i] += field_dict[key][:,i]
                        else:
                            field[:,i] += field_dict[key][:,i] 

                field_max = np.amax(abs(field))
                
                for t in range(len(self.t)):
                    fig, ax = plt.subplots(figsize=(10, 5))
                    plt.grid(which='major')
                    ax.yaxis.set_major_locator(MultipleLocator(deltay_axis))
                    ax.xaxis.set_major_locator(MultipleLocator(deltax_axis))
                    
                    plt.plot(self.lp[key] ,abs(field[t,:]))
                    plt.title('t = '+str(self.t[t])+ 's',fontsize = 17); plt.xlabel('l (m)'); plt.ylabel(name +' ('+ units+')')
                    plt.ylim([0, field_max*1.05])
                    plt.xlim([0, self.lp[key][-1]])
                    
                    if t>=10 and t<100:
                        d=j2+str(t)
                    elif t<10:
                        d=j1+str(t)
                    else:
                        d=j3+str(t)
                        
                    fig.savefig(self.p+'/images/'+name+'/'+d)
                    plt.close(fig)

                os.chdir(self.p+'/images/'+name)
                os.system("ffmpeg -framerate 4 -i imagen%03d.png {}.mp4".format(name))

                if clean == True:
                    shutil.copy(self.p+'/images/'+name+'/'+name+'.mp4', self.p+'/images/'+name+'.mp4')
                    clean_dir(path, name)

        def plot_h_tp_time(self, key, index, save = False):
                self.plot_fieldtp_time(self.h_tp, key, index, 'h', 'm', 1, save)

        def plot_Us_m_tp_time(self, key, index, save = False):
                self.plot_fieldtp_time(self.Us_m_tp, key, index, 'Us_m', 'm/s', 1, save)
                
        def plot_deltac0_tp_time(self, key, index, sign, save = False):
                self.plot_fieldtp_time(self.deltac0_tp, key, index, 'deltac0', 'm', sign, save)

        def plot_deltah0_tp_time(self, key, index, sign, save = False):
                self.plot_fieldtp_time(self.deltah0_tp, key, index, 'deltah0', 'm', sign, save)

        def plot_fieldtp_time(self, field, key, index, name, units, sign, save):
                field_tp_time = np.zeros((len(self.t),1))
                for t in range(len(self.t)):
                    field_tp_time[t,0] = max(field[key][t][index]*sign)*sign
                   
                fig = plt.figure(figsize = (8,8))
                plt.plot(self.t,field_tp_time[:,0])
                plt.grid(True)
                tit = 'index = '+ str(index)
                plt.title(tit,fontsize = 17); plt.xlabel('t (s)'); plt.ylabel(name +' ('+ units+')')                

                if save == True:
                    path = self.p+'/images'
                    fig.savefig(path+'/'+name+'_tp_time_index_'+str(index))
                    plt.close(fig)

        def plot_Sm_max(self):
                self.plot_field_max(self.Sm, 'Sm', 'm/s' )

#        def plot_h_max(self):
#                self.plot_field_max(self.h, 'h', 'm' )
#
#        def plot_deltac0_max(self, sign = 1):
#                self.plot_field_max(self.deltac0, 'deltac0', 'm', sign)
#
#        def plot_deltah0_max(self, sign = 1):
#                self.plot_field_max(self.deltah0, 'deltah0', 'm', sign)
#
#        def plot_Us_m_max(self):
#                self.plot_field_max(self.Us_m, 'Us_m', 'm/s' )
#                
#        def plot_Cv_max(self):
#                self.plot_field_max(self.Cv, 'Cv', '-' )

        def plot_field_max(self, field, name, units, sign = 1):
                field_max = np.zeros((len(self.t),1))
                for t in range(len(self.t)):
                    field_max[t,0] = np.amax(field[t,:,:]*sign)*sign

                fig = plt.figure(figsize = (8,8))
                plt.plot(self.t,field_max[:,0])
                plt.grid(True)
                plt.xlabel('t (s)'); 
                plt.ylabel(name +' ('+ units+')')                 

        def plot_hmax_image(self,t_final,im_name,off_x = 0,off_y = 0,clipp=False, xmin=0, xmax=0, ymin=0, ymax=0, figsize_x = 8, figsize_y = 8,n_intervals = 8, save = False):
                self.plot_fieldmax_image(self.h,t_final,im_name,'h', 'm',off_x,off_y,clipp, xmin, xmax, ymin, ymax,figsize_x,figsize_y,n_intervals,save)

        def plot_Usmax_image(self,t_final,im_name,off_x = 0,off_y = 0,clipp=False, xmin=0, xmax=0, ymin=0, ymax=0, figsize_x = 8, figsize_y = 8,n_intervals = 8, save = False):
                self.plot_fieldmax_image(self.Us_m,t_final,im_name,'Us', 'm/s',off_x,off_y,clipp, xmin, xmax, ymin, ymax,figsize_x,figsize_y,n_intervals,save)

        def plot_deltac0max_image(self,t_final,im_name,off_x = 0,off_y = 0,clipp=False, xmin=0, xmax=0, ymin=0, ymax=0, figsize_x = 8, figsize_y = 8,n_intervals = 8, save = False):
                self.plot_fieldmax_image(self.deltac0,t_final,im_name,'d', 'm',off_x,off_y,clipp, xmin, xmax, ymin, ymax,figsize_x,figsize_y,n_intervals,save,-1)

        def plot_Cvmax_image(self,t_final,im_name,off_x = 0,off_y = 0,clipp=False, xmin=0, xmax=0, ymin=0, ymax=0, figsize_x = 8, figsize_y = 8,n_intervals = 8, save = False):
                self.plot_fieldmax_image(self.Cv,t_final,im_name,'Cv', '-',off_x,off_y,clipp, xmin, xmax, ymin, ymax,figsize_x,figsize_y,n_intervals,save)

        def plot_h_image(self,t,im_name,off_x = 0,off_y = 0,clipp=False, xmin=0, xmax=0, ymin=0, ymax=0, figsize_x = 8, figsize_y = 8,n_intervals = 8,nx = 0,ny = 0,save = False):
                self.plot_field_image(self.h,t,im_name,'h', 'm',off_x,off_y,clipp, xmin, xmax, ymin, ymax,figsize_x,figsize_y,n_intervals,nx,ny,save)

        def plot_Us_image(self,t,im_name,off_x = 0,off_y = 0,clipp=False, xmin=0, xmax=0, ymin=0, ymax=0, figsize_x = 8, figsize_y = 8,n_intervals = 8,nx = 0,ny = 0,save = False):
                self.plot_field_image(self.Us_m,t,im_name,'Us', 'm/s',off_x,off_y,clipp, xmin, xmax, ymin, ymax,figsize_x,figsize_y,n_intervals,nx,ny,save)

        def plot_Cv_image(self,t,im_name,off_x = 0,off_y = 0,clipp=False, xmin=0, xmax=0, ymin=0, ymax=0,figsize_x = 8,figsize_y = 8,n_intervals = 8,nx = 0,ny = 0,save = False):
                self.plot_field_image(self.Cv,t,im_name,'Cv', '-',off_x,off_y,clipp, xmin, xmax, ymin, ymax,figsize_x,figsize_y,n_intervals,nx,ny,save)

        def plot_deltac0_image_video(self,t,im_name,off_x = 0,off_y = 0,clipp=False, xmin=0, xmax=0, ymin=0, ymax=0, figsize_x = 8, figsize_y = 8,n_intervals = 8,nx = 0,ny = 0,save = False):
                self.plot_field_image_video(self.deltac0,t,im_name,'deltac0', 'm',off_x,off_y,clipp, xmin, xmax, ymin, ymax,figsize_x,figsize_y,n_intervals,nx,ny,save)

        def plot_h_image_video(self,im_name,off_x = 0,off_y = 0,n_intervals = 8, clean = True, figsize_x = 8, figsize_y = 8):
                self.plot_field_image_video(self.h,im_name,'h', 'm',off_x,off_y,n_intervals,clean,figsize_x,figsize_y)

        def plot_Us_image_video(self,im_name,off_x = 0,off_y = 0,n_intervals = 8, clean = True, figsize_x = 8, figsize_y = 8):
                self.plot_field_image_video(self.Us_m,im_name,'Us', 'm/s',off_x,off_y,n_intervals,clean,figsize_x,figsize_y)

        def plot_Cv_image_video(self,im_name,off_x = 0,off_y = 0,n_intervals = 8, clean = True, figsize_x = 8, figsize_y = 8):
                self.plot_field_image_video(self.Cv,im_name,'Cv', '-',off_x,off_y,n_intervals,clean,figsize_x,figsize_y)

        def plot_deltac0_image_video(self,im_name,off_x = 0,off_y = 0,n_intervals = 8, clean = True, figsize_x = 8, figsize_y = 8):
                self.plot_field_image_video(self.deltac0,im_name,'deltac0', 'm',off_x,off_y,n_intervals,clean,figsize_x,figsize_y)

        def plot_field_image_video(self,field,im_name, name, units, off_x, off_y, n_intervals, clean, figsize_x, figsize_y):
                j1='imagen00'
                j2='imagen0'
                j3='imagen'
                
                make_dir(self.p, 'images')
                path = self.p+'/images'
                clean_dir(path, name)
                make_dir(path, name)

                extent = [self.x[0]+off_x,self.x[-1]+off_x,self.y[0]+off_y,self.y[-1]+off_y]
                im = plt.imread(self.p+'/'+im_name)

                for t in range(len(self.t)):                
                    fig, ax = plt.subplots(figsize=(figsize_x, figsize_y))
                    ax.imshow(im,extent = extent)
                    plt.grid()
                                    
                    x, y, arrow_length = 0.1, 0.2, 0.1
                    ax.annotate('N', xy=(x, y), xytext=(x, y-arrow_length),
                        arrowprops=dict(facecolor='black', width=5, headwidth=15),
                        ha='center', va='center', fontsize=20,
                        xycoords=ax.transAxes)
    
                    colors = []
                    for c in np.linspace(0,1,n_intervals+1):
                        if len(colors) > 1:
                            colors.append((c,abs(0.5-c),1-c,1))
                        elif len(colors) == 1:
                            colors.append((c,abs(0.5-c),1-c,0.5))
                        else:
                            colors.append((c,abs(0.5-c),1-c,0))
                    mycmap = mcolors.ListedColormap(colors)
                    
                    field_t = field[t,:,:].transpose()
                    field_inv = field_t*0
                    nrows = field_t.shape[0]
                    for i in range(nrows):
                        field_inv[i,:] = field_t[nrows-1-i,:]
    
                    max_field = max(round(np.amax(field_inv),1),0.5)
                    a = [0,0.001]
                    ticks = [0]
                    for i in range(n_intervals):
                        a.append(round(max_field*(i+1)/(n_intervals),2))
                        ticks.append(round(max_field*(i+1)/(n_intervals),2))
                    
                    a = np.array([a])
                    norm = mcolors.BoundaryNorm(a[0], len(a[0])-1)
                    img= plt.imshow(field_inv,cmap=mycmap,extent=extent,norm = norm)
                    cbar = fig.colorbar(img, ticks = ticks, spacing = 'proportional',label= name+' ('+units+')')
                    ticks_names = []
                    for tick in ticks: ticks_names.append(str(tick))
                    cbar.ax.set_yticklabels(ticks)
                    plt.xlabel('x (m)'); plt.ylabel('y (m)')

                    if t>=10 and t<100:
                        d=j2+str(t)
                    elif t<10:
                        d=j1+str(t)
                    else:
                        d=j3+str(t)

                    plt.title('t= '+str(self.t[t])+' s',fontsize = 17)
                    fig.savefig(self.p+'/images/'+name+'/'+d)
                    plt.close(fig)
                    
                os.chdir(self.p+'/images/'+name)
                os.system("ffmpeg -framerate 3 -i imagen%03d.png {}.mp4".format(name))
                
                if clean == True:
                    shutil.copy(self.p+'/images/'+name+'/'+name+'.mp4', self.p+'/images/'+name+'.mp4')
                    clean_dir(path, name)

        def plot_field_image(self,field,t,im_name, name, units, off_x, off_y,clipp, xmin, xmax, ymin, ymax,figsize_x,figsize_y,n_intervals,nx,ny,save):
                im = plt.imread(self.p+'/'+im_name)
                fig, ax = plt.subplots(figsize=(figsize_x, figsize_y))
                if clipp == False:
                    extent = [self.x[0]+off_x,self.x[-1]+off_x,self.y[0]+off_y,self.y[-1]+off_y]
                else:
                    extent = [self.x[0]+xmin+off_x,self.x[0]+xmax+off_x,self.y[0]+ymin+off_y,self.y[0]+ymax+off_y]
                    alpha_xmin = (xmin)/(self.x[-1]-self.x[0]); alpha_xmax = (xmax)/(self.x[-1]-self.x[0])
                    alpha_ymin = 1-(ymin)/(self.y[-1]-self.y[0]); alpha_ymax = 1-(ymax)/(self.y[-1]-self.y[0])
                    i_xmin = int(alpha_xmin*im.shape[1]); i_xmax = int(alpha_xmax*im.shape[1])+1
                    i_ymin = int(alpha_ymin*im.shape[0]); i_ymax = int(alpha_ymax*im.shape[0])+1
                    im = im[i_ymax:i_ymin, i_xmin:i_xmax]

                colors = []
                for c in np.linspace(0,1,n_intervals+1):
                    if len(colors) > 1:
                        colors.append((c,abs(0.5-c),1-c,1))
                    elif len(colors) == 1:
                        colors.append((c,abs(0.5-c),1-c,0.5))
                    else:
                        colors.append((c,abs(0.5-c),1-c,0))
                mycmap = mcolors.ListedColormap(colors)

                if type(t) == list:
                    for t_i in range(len(t)):
                        plt.subplot(nx,ny,t_i+1)
                        plt.imshow(im,extent = extent, aspect='auto')
                        plt.grid()
                        j = self.t.index(t[t_i])
                        field_t = field[j,:,:].transpose()
                        field_inv = field_t*0
                        nrows = field_t.shape[0]
                        for i in range(nrows):
                            field_inv[i,:] = field_t[nrows-1-i,:]
                        if clipp == True:
                            i_xmin = int(xmin/(self.x[1]-self.x[0])); i_xmax = int(xmax/(self.x[1]-self.x[0]))
                            i_ymin = int((self.y[-1]-ymin)/(self.y[1]-self.y[0])); i_ymax = int((self.y[-1]-ymax)/(self.y[1]-self.y[0]))
                            field_inv = field_inv[i_ymax:i_ymin,i_xmin:i_xmax]  
        
                        max_field = round(np.amax(field_inv),1)
                        a = [0,0.001]
                        ticks = [0]
                        for i in range(n_intervals):
                            a.append(round(max_field*(i+1)/(n_intervals),2))
                            ticks.append(round(max_field*(i+1)/(n_intervals),2))
                    
                        a = np.array([a])
                        norm = mcolors.BoundaryNorm(a[0], len(a[0])-1)
                        img= plt.imshow(field_inv,cmap=mycmap,extent=extent,norm = norm)
                        cbar = fig.colorbar(img, pad = 0.025, ticks = ticks, spacing = 'proportional')
                        ticks_names = []
                        for tick in ticks: ticks_names.append(str(tick))
                        cbar.ax.set_yticklabels(ticks)
                        plt.title('t = ' + str(t[t_i])+' s', fontsize = 12)
                        
                        if t_i == len(t)-1:
                            cbar.ax.set_ylabel(name+' ('+units+')',  fontsize = 12)
                        if t_i != 0:
                            plt.tick_params(labelleft = False)
                            
                    plt.subplots_adjust(wspace=-0.2)
                else:
                    ax.imshow(im,extent = extent, aspect='auto')
                    plt.grid()

                    x, y, arrow_length = 0.1, 0.2, 0.1
                    ax.annotate('N', xy=(x, y), xytext=(x, y-arrow_length),
                        arrowprops=dict(facecolor='black', width=5, headwidth=15),
                        ha='center', va='center', fontsize=20,
                        xycoords=ax.transAxes)
                                                   
                    j = self.t.index(t)
                    field_t = field[j,:,:].transpose()
                    field_inv = field_t*0
                    nrows = field_t.shape[0]
                    for i in range(nrows):
                        field_inv[i,:] = field_t[nrows-1-i,:]
                    if clipp == True:
                        i_xmin = int(xmin/(self.x[1]-self.x[0])); i_xmax = int(xmax/(self.x[1]-self.x[0]))
                        i_ymin = int((self.y[-1]-ymin)/(self.y[1]-self.y[0])); i_ymax = int((self.y[-1]-ymax)/(self.y[1]-self.y[0]))
                        field_inv = field_inv[i_ymax:i_ymin,i_xmin:i_xmax] 
    
                    max_field = round(np.amax(field_inv),1)
                    a = [0,0.001]
                    ticks = [0]
                    for i in range(n_intervals):
                        a.append(round(max_field*(i+1)/(n_intervals),2))
                        ticks.append(round(max_field*(i+1)/(n_intervals),2))
                    a = np.array([a])
                    norm = mcolors.BoundaryNorm(a[0], len(a[0])-1)
               
                    img= ax.imshow(field_inv,cmap=mycmap,extent=extent,norm = norm)
                    cbar = fig.colorbar(img, pad = 0.025, ticks = ticks, spacing = 'proportional')
                    cbar.ax.set_ylabel(name+' ('+units+')',  fontsize = 12)
                    ticks_names = []
                    for tick in ticks: ticks_names.append(str(tick))
                    cbar.ax.set_yticklabels(ticks)
                    
                if save == True:
                    path = self.p+'/images'
                    fig.savefig(path+'/'+name+'_t_'+str(t), dpi = 100)
                    plt.close(fig)

        def plot_fieldmax_image(self,field,t_final,im_name, name, units, off_x, off_y, clipp, xmin, xmax, ymin, ymax, figsize_x, figsize_y, n_intervals, save, sign = 1):
                im = plt.imread(self.p+'/'+im_name)
                fig, ax = plt.subplots(figsize=(figsize_x, figsize_y))
                if clipp == False:
                    extent = [self.x[0]+off_x,self.x[-1]+off_x,self.y[0]+off_y,self.y[-1]+off_y]
                else:
                    extent = [self.x[0]+xmin+off_x,self.x[0]+xmax+off_x,self.y[0]+ymin+off_y,self.y[0]+ymax+off_y]
                    alpha_xmin = (xmin)/(self.x[-1]-self.x[0]); alpha_xmax = (xmax)/(self.x[-1]-self.x[0])
                    alpha_ymin = 1-(ymin)/(self.y[-1]-self.y[0]); alpha_ymax = 1-(ymax)/(self.y[-1]-self.y[0])
                    i_xmin = int(alpha_xmin*im.shape[1]); i_xmax = int(alpha_xmax*im.shape[1])+1
                    i_ymin = int(alpha_ymin*im.shape[0]); i_ymax = int(alpha_ymax*im.shape[0])+1
                    im = im[i_ymax:i_ymin, i_xmin:i_xmax]
                ax.imshow(im,extent = extent, aspect='auto')    
                plt.grid()
                                
                x, y, arrow_length = 0.1, 0.2, 0.15
                ax.annotate('N', xy=(x, y), xytext=(x, y-arrow_length),
                    arrowprops=dict(facecolor='black', width=5, headwidth=15),
                    ha='center', va='center', fontsize=20,
                    xycoords=ax.transAxes)

                colors = []
                for c in np.linspace(0,1,n_intervals+1):
                    if len(colors) > 1:
                        colors.append((c,abs(0.5-c),1-c,1))
                    elif len(colors) == 1:
                        colors.append((c,abs(0.5-c),1-c,0.5))
                    else:
                        colors.append((c,abs(0.5-c),1-c,0))
                mycmap = mcolors.ListedColormap(colors)
 
                field_max = np.zeros((len(self.y), len(self.x)))
                j = 0
                
                while True:
                    field_t = field[j,:,:].transpose()
                    field_inv = field_t*0
                    nrows = field_t.shape[0]
                    for i in range(nrows):
                        field_inv[i,:] = field_t[nrows-1-i,:]
                    for i in range(field_t.shape[0]):
                        for k in range(field_t.shape[1]):
                            field_max[i,k] = max(field_max[i,k]*sign, field_inv[i,k]*sign)*sign
                    if self.t[j] >= t_final:
                        break                    
                    j += 1

                max_field = round(np.amax(field_max*sign),3)
                a = [0,0.001]
                ticks = [0]
                for i in range(n_intervals):
                    a.append(round(max_field*(i+1)/(n_intervals),2))
                    ticks.append(round(max_field*(i+1)/(n_intervals),2))
                a = np.array([a])
                norm = mcolors.BoundaryNorm(a[0], len(a[0])-1)
                if clipp == True:
                    i_xmin = int(xmin/(self.x[1]-self.x[0])); i_xmax = int(xmax/(self.x[1]-self.x[0]))
                    i_ymin = int((self.y[-1]-ymin)/(self.y[1]-self.y[0])); i_ymax = int((self.y[-1]-ymax)/(self.y[1]-self.y[0]))
                    field_max = field_max[i_ymax:i_ymin,i_xmin:i_xmax]
                img= ax.imshow(field_max*sign,cmap=mycmap,extent=extent,norm = norm)
                cbar = fig.colorbar(img, ticks = ticks, spacing = 'proportional',label= name+' ('+units+')')
                ticks_names = []
                for tick in ticks: ticks_names.append(str(tick))
                cbar.ax.set_yticklabels(ticks)

                if save == True:
                    path = self.p+'/images'
                    fig.savefig(path+'/'+name+'_max')
                    plt.close(fig)

        def get_VELFP(self, off_x, off_y, d_x = 10, d_y = 10): 
                self.VELFP = np.zeros((int((self.x[-1]-self.x[0])/d_x)+1, int((self.y[-1]-self.y[0])/d_y)+1))
                self.get_FP_field('VELFP.OUT', self.VELFP, off_x, off_y, d_x, d_y)

        def get_DEPFP(self, off_x, off_y, d_x = 10, d_y = 10): 
                self.DEPFP = np.zeros((int((self.x[-1]-self.x[0])/d_x)+1, int((self.y[-1]-self.y[0])/d_y)+1))
                self.get_FP_field('DEPFP.OUT', self.DEPFP, off_x, off_y, d_x, d_y)

        def get_FP_field(self, name, output, off_x, off_y, d_x, d_y):            
                data = open(self.p+'/'+name,"r")
                data_lines = data.readlines()
                data.close()

                min_x = self.x[0]+off_x
                min_y = self.y[0]+off_y

                for j in range(len(data_lines)):
                    list = data_lines[j].split()   
                    i_x = int((float(list[1])-min_x)/d_x)
                    i_y = int((float(list[2])-min_y)/d_y)
                    
                    if (i_x < output.shape[0] and i_x >= 0) and (i_y < output.shape[1] and i_y >= 0):
                        output[i_x, i_y] = float(list[3])

        def get_DEPFP_tp(self, key, d_x = 10, d_y = 10):
                self.DEPFP_tp = np.zeros((len(self.tp[key]),len(self.tp[key][0])))
                self.DEPFP_tp_max = np.zeros((len(self.tp[key]),1))
                self.get_FP_field_tp(self.DEPFP, self.DEPFP_tp, self.DEPFP_tp_max, key, d_x, d_y)

        def get_VELFP_tp(self, key, d_x = 10, d_y = 10):
                self.VELFP_tp = np.zeros((len(self.tp[key]),len(self.tp[key][0])))
                self.VELFP_tp_max = np.zeros((len(self.tp[key]),1))
                self.get_FP_field_tp(self.VELFP, self.VELFP_tp, self.VELFP_tp_max, key, d_x, d_y)

        def get_FP_field_tp(self, field, output, output_max, key, d_x, d_y):
                x = np.arange(self.x[0], self.x[-1]+d_x,d_x)
                y = np.arange(self.y[0], self.y[-1]+d_y,d_y)
                for i in range(len(self.tp[key])):
                    for j in range(len(self.tp[key][i])):
                        v = self.tp[key][i][j]
                        i_x = int((float(v.x)-x[0])/d_x)
                        i_y = int((float(v.y)-y[0])/d_y)
                        output[i,j] = field[i_x,i_y]
                        
                    output_max[i,0] = max(output[i,:])

        def plot_VELFP(self, d_x = 10, d_y = 10):
                self.plot_FP_field(self.VELFP, d_x, d_y)

        def plot_DEPFP(self, d_x = 10, d_y = 10):
                self.plot_FP_field(self.DEPFP, d_x, d_y)

        def plot_FP_field(self, field, d_x, d_y):
                field_t = field.transpose()
                x = np.arange(self.x[0], self.x[-1]+d_x, d_x)
                y = np.arange(self.y[0], self.y[-1]+d_y, d_y)
                fig, ax = plt.subplots(figsize=(8,8))
                plt.contourf(x,y,field_t,cmap = plt.get_cmap('hot'))
                plt.xlabel('x (m)'); plt.ylabel('y (m)')
                plt.colorbar()
                plt.grid()                    

        def activate_all(self):
                self.activate_h()
                self.activate_pb()
                self.activate_Cv()
                self.activate_deltaz0()
                self.activate_Us()
                self.activate_tau()
                self.activate_Q()
                self.activate_phi2s()
                self.activate_Sm()
                self.activate_rho()
                self.activate_V()
                self.activate_M()
                self.activate_Vsed()
                self.activate_rcg()

        def activate_h(self):
                self.h_flag = 'on'
                
        def activate_pb(self):
                self.pb_flag = 'on'                
                
        def activate_Cv(self):
                self.Cv_flag = 'on'                
                
        def activate_deltaz0(self):
                self.deltaz0_flag = 'on'                
                
        def activate_Us(self):
                self.Us_flag = 'on'                
                
        def activate_tau(self):
                self.tau_flag = 'on'

        def activate_Q(self):
                self.Q_flag = 'on'
                
        def activate_phi2s(self):
                self.phi2s_flag = 'on'                
                
        def activate_Sm(self):
                self.Sm_flag = 'on'                
                
        def activate_rho(self):
                self.rho_flag = 'on'                
                
        def activate_V(self):
                self.V_flag = 'on'                
                
        def activate_M(self):
                self.M_flag = 'on'

        def activate_Vsed(self):
                self.Vsed_flag = 'on'                
                
        def activate_rcg(self):
                self.rcg_flag = 'on'

        def clean_h(self):
                self.h = []
                self.h_tp = {}

        def clean_he(self):
                self.he = []
                self.he_tp = {}

        def clean_z(self):
                self.z = []
                self.z_tp = {}

        def clean_Us(self):
                self.Us = []
                self.Us_m_tp = {}

        def clean_deltah0(self):
                self.deltah0 = []
                self.deltah0_tp = {}

        def clean_deltac0(self):
                self.deltac0 = []
                self.deltac0_tp = {}

        def clean_pb(self):
                self.pb = []

        def clean_Cv(self):
                self.Cv = []

        def clean_tau(self):
                self.tau = []
                
        def clean_Sm(self):
                self.Sm = []

        def clean_rho(self):
                self.rho = []

        def clean_rcg(self):
                self.rcg = []

        def clean_M(self):
                self.M = []

        def clean_Cv_avrg(self):
                self.Cv_avrg = []

        def clean_V(self):
                self.V = []
                
        def clean_Vsed(self):
                self.Vsed = []

        def clean_Q(self):
                self.Q = {}
                
        def clean_phi2s(self):
                self.phi2s = {}


class Comparison:
        def __init__(self, path = '', list_names = [], h='off',pb='off',Cv='off',deltac0='off' ,deltah0='off',Us='off',tau='off',phi2s='off',Q='off',Sm='off',rho='off',V='off',M='off',Vsed='off',rcg='off'):
                self.p = path
                
                self.list_names = list_names
                self.list_Results = []
                self.list_paths = []

                self.h = {}
                self.pb = {}
                self.Cv = {}
                self.deltah0 = {}
                self.deltac0 = {}
                self.Us = {}
                self.tau = {}
                self.Q = {}
                self.phi2s = {}
                self.Sm = {}
                self.rho = {}                
                self.V = {}
                self.M = {}
                self.Vsed = {}
                self.rcg = {}
                
                self.z_tp = {}
                self.he_tp = {}
                self.h_tp = {}
                self.Us_m_tp = {}
                self.deltah0_tp = {}
                self.deltac0_tp = {}
                
                self.deltac0_tp_max = {}
                self.deltah0_tp_max = {}
                self.h_tp_max = {}

                self.x = []
                self.y = []
                self.z = []
#                self.he = []
                self.t = []
#                self.tps = {}
#                self.rF_V = []
#                self.rF_M = []
                self.lp = {}
                self.lp_c = {}
                self.tp = {}
                
#                self.h_flag = h
#                self.pb_flag = pb
#                self.Cv_flag = Cv
#                self.deltac0_flag = deltac0
#                self.deltah0_flag = deltah0
#                self.Us_flag = Us
#                self.tau_flag = tau
#                self.Q_flag = Q
#                self.phi2s_flag = phi2s
#                self.Sm_flag = Sm
#                self.rho_flag = rho
#                self.V_flag = V
#                self.M_flag = M
#                self.Vsed_flag = Vsed
#                self.rcg_flag = rcg

                self.get_case()
            
        def get_case(self):
                self.get_path_list()
                self.get_basic_data()
                
        def get_path_list(self):
                if self.p != '' and len(self.list_names) == 0:
                    listdir = os.listdir(self.p)
                    for dir in listdir:
                        sub_listdir = os.listdir(self.p+'/'+dir)
                        if 'Results' in sub_listdir:
                            self.list_paths.append(self.p+'/'+dir)
                            self.list_names.append(dir)
                            self.list_Results.append(Results(self.p+'/'+dir))
                else:
                    for i in range(len(self.list_names)):
                        sub_listdir = os.listdir(self.p+'/'+self.list_names[i])
                        if 'Results' in sub_listdir:
                            self.list_paths.append(self.p+'/'+self.list_names[i])
                            self.list_Results.append(Results(self.p+'/'+self.list_names[i]))

        def get_basic_data(self):
                self.x = self.list_Results[0].x
                self.y = self.list_Results[0].y
                self.z = self.list_Results[0].z
                self.t = self.list_Results[0].t
                self.lp = self.list_Results[0].lp
                self.lp_c = self.list_Results[0].lp_c
                self.tp = self.list_Results[0].tp               

        def get_he_tp(self):
                self.list_Results[0].get_he_tp()
                self.he_tp = self.list_Results[0].he_tp
                self.list_Results[0].clean_he()

        def get_z_tp(self):
                self.list_Results[0].get_z_tp()
                self.z_tp = self.list_Results[0].z_tp
                self.list_Results[0].clean_z()

        def get_h(self):
                for i in range(len(self.list_Results)):
                    self.list_Results[i].activate_h()
                    self.list_Results[i].get_h()
                    self.h[self.list_names[i]] = self.list_Results[i].h
                    self.list_Results[i].clean_h()

        def get_Sm(self):
                for i in range(len(self.list_Results)):
                    self.list_Results[i].activate_Sm()
                    self.list_Results[i].get_Sm()
                    self.Sm[self.list_names[i]] = self.list_Results[i].Sm
                    self.list_Results[i].clean_Sm()

        def get_Q(self):
                for i in range(len(self.list_Results)):
                    self.list_Results[i].activate_Q()
                    self.list_Results[i].get_Q()
                    self.Q[self.list_names[i]] = self.list_Results[i].Q
                    self.list_Results[i].clean_Q()

        def get_rcg(self):
                for i in range(len(self.list_Results)):
                    self.list_Results[i].activate_rcg()
                    self.list_Results[i].get_rcg()
                    self.rcg[self.list_names[i]] = self.list_Results[i].rcg
                    self.list_Results[i].clean_rcg()

        def get_h_tp(self):
                for i in range(len(self.list_Results)):
                    self.list_Results[i].activate_h()
                    self.list_Results[i].get_h_tp()
                    self.h_tp[self.list_names[i]] = self.list_Results[i].h_tp
                    self.list_Results[i].clean_h()

        def get_Us_m_tp(self):
                for i in range(len(self.list_Results)):
                    self.list_Results[i].activate_Us()
                    self.list_Results[i].get_Us_m_tp()
                    self.Us_m_tp[self.list_names[i]] = self.list_Results[i].Us_m_tp
                    self.list_Results[i].clean_Us()
                    
        def get_deltah0_tp(self):
                for i in range(len(self.list_Results)):
                    self.list_Results[i].activate_deltaz0()
                    self.list_Results[i].get_deltah0_tp()
                    self.deltah0_tp[self.list_names[i]] = self.list_Results[i].deltah0_tp
                    self.list_Results[i].clean_deltah0()                    

        def get_deltac0_tp(self):
                for i in range(len(self.list_Results)):
                    self.list_Results[i].activate_deltaz0()
                    self.list_Results[i].get_deltac0_tp()
                    self.deltac0_tp[self.list_names[i]] = self.list_Results[i].deltac0_tp
                    self.list_Results[i].clean_deltac0()

        def get_h_tp_max(self):
                for i in range(len(self.list_Results)):
                    self.list_Results[i].activate_h()
                    self.list_Results[i].get_h_tp()
                    self.list_Results[i].get_h_tp_max()
                    self.h_tp_max[self.list_names[i]] = self.list_Results[i].h_tp_max
                    self.list_Results[i].clean_h()

        def get_deltac0_tp_max(self):
                for i in range(len(self.list_Results)):
                    self.list_Results[i].activate_deltaz0()
                    self.list_Results[i].get_deltac0_tp()
                    self.list_Results[i].get_deltac0_tp_max()
                    self.deltac0_tp_max[self.list_names[i]] = self.list_Results[i].deltac0_tp_max
                    self.list_Results[i].clean_deltac0()

        def get_deltah0_tp_max(self):
                for i in range(len(self.list_Results)):
                    self.list_Results[i].activate_deltaz0()
                    self.list_Results[i].get_deltah0_tp()
                    self.list_Results[i].get_deltah0_tp_max()
                    self.deltah0_tp_max[self.list_names[i]] = self.list_Results[i].deltah0_tp_max
                    self.list_Results[i].clean_deltah0()

        def get_V(self):
                for i in range(len(self.list_Results)):
                    self.list_Results[i].activate_V()
                    self.list_Results[i].get_V()
                    self.V[self.list_names[i]] = self.list_Results[i].V
                    self.list_Results[i].clean_V()

        def get_M(self):
                for i in range(len(self.list_Results)):
                    self.list_Results[i].activate_M()
                    self.list_Results[i].get_M()
                    self.M[self.list_names[i]] = self.list_Results[i].M
                    self.list_Results[i].clean_M()

        def plot_h_tp_max(self,key,deltax_axis = 30,deltay_axis = 0.5):
                self.plot_lpfield_max(key, self.h_tp_max, 'h', 'm', deltax_axis, deltay_axis)

        def plot_deltac0_tp_max(self,key,deltax_axis = 30,deltay_axis = 0.5):
                self.plot_lpfield_max(key, self.deltac0_tp_max, 'Profundidad de erosión', 'm', deltax_axis, deltay_axis)

        def plot_deltah0_tp_max(self,key,deltax_axis = 30,deltay_axis = 0.5, clipp = False, xmin=0, xmax=0):
                self.plot_lpfield_max(key, self.deltah0_tp_max, 'Profundidad de erosión', 'm', deltax_axis, deltay_axis, clipp, xmin, xmax)

        def plot_lpfield_max(self,key, field_dict, name, units, deltax_axis, deltay_axis, clipp, xmin, xmax):
                fig, ax = plt.subplots(figsize=(10, 5))
                ax.yaxis.set_major_locator(MultipleLocator(deltay_axis))
                ax.xaxis.set_major_locator(MultipleLocator(deltax_axis))
                for s_key in field_dict.keys():
                    field = field_dict[s_key][key]
                    if clipp == False:                                             
                        line, = plt.plot(self.lp[key],abs(field[:,0]), label = s_key)
                    else:
                        line, = plt.plot(self.lp[key][xmin:xmax],abs(field[:,0])[xmin:xmax], label = s_key)
                if clipp == False:
                    plt.xlim([-deltax_axis*0.25, self.lp[key][-1]+deltax_axis*0.25])
                else:
                    plt.xlim([-deltax_axis*0.25+self.lp[key][xmin], self.lp[key][xmax]+deltax_axis*0.25])
                plt.ylim([-deltay_axis*0.25,  1.05*max(abs(field[:,0]))+deltay_axis*0.25])
                plt.grid(True)
                plt.legend(handler_map= {})
                plt.xlabel('l (m)', fontsize = 14); plt.ylabel(name +' ('+ units+')', fontsize = 14)

                plt.plot([self.lp[key][139],self.lp[key][139]],[-10,15], color = 'black', linestyle = 'dashed', linewidth = 1.5)
                plt.plot([self.lp[key][280],self.lp[key][280]],[-10,15], color = 'black', linestyle = 'dashed', linewidth = 1.5)
                plt.plot([self.lp[key][215],self.lp[key][215]],[-10,15], color = 'black', linestyle = 'dashed', linewidth = 1.5)
#                
#                line2, = plt.plot([self.lp[key][139],self.lp[key][280]],[5.64,5.64], color = 'brown', linestyle = 'dashed', linewidth = 1.5, label = 'prom1')
#                line3, = plt.plot([self.lp[key][159],self.lp[key][280]],[5.36,5.36], color = 'green', linestyle = 'dashed', linewidth = 1.5, label = 'prom2')
#                
                text(self.lp[key][141], 1.2, "check dam 28", rotation=90, verticalalignment='top')
                text(self.lp[key][282], 1.2, "check dam 29", rotation=90, verticalalignment='top')
                text(self.lp[key][217], 1.2, "sensores de erosión", rotation=90, verticalalignment='top')

        def plot_deltac0_tp(self,key,index,time,xmin = -1, xmax = -1,save = False):
                self.plot_field_tp(key,index,time,self.deltac0,'z','m',xmin,xmax,save)

        def plot_field_tp(self, key, index, time, field, name, units, xmin, xmax, save):
                fig, ax = plt.subplots(figsize=(10, 10))
                j = self.t.index(time)
                he_tp = np.array(self.he_tp[key][index])
                z_tp = np.array(self.z_tp[key][index])

                dists = [0]*len(self.tp[key][index])
                dist_max = distxy(self.tp[key][index][0], self.tp[key][index][-1])
                
                for i in range(len(dists)):
                    dists[i] = distxy(self.tp[key][index][0], self.tp[key][index][i])-dist_max/2

                if xmin != -1:
                    imin = int((xmin-dists[0])/dist_max*len(dists))
                else:
                    imin = 0
                if xmax != -1:
                    imax = int((xmax-dists[0])/dist_max*len(dists))+1
                else:
                    imax = len(dists)

                line1, = plt.plot(dists[imin:imax], z_tp[imin:imax], label = 'initial bottom') 
                line2, = plt.plot(dists[imin:imax], (z_tp-he_tp)[imin:imax],label = 'initial erodible layer')

                for R_key in range(len(self.list_Results)):
                    case = self.list_names[R_key]
                    deltac0_tp = np.array(self.deltac0_tp[case][key][j][index])
                    line3, = plt.plot(dists[imin:imax], (deltac0_tp+z_tp)[imin:imax], label = case+' final bottom')                    
                    
                plt.grid(True)
                plt.xlabel('x (m)', fontsize = 14)
                plt.ylabel('z (m)', fontsize = 14)

                plt.legend(handler_map= {})                   

        def plot_Q_tp(self,key_list,index,deltax_axis = 20,deltay_axis = 20,figsize_x = 10,figsize_y = 5,save = False):
                self.plot_lpfield_tp(key_list,index,self.Q,'Q','m³/s',deltax_axis,deltay_axis,figsize_x,figsize_y,save)

        def plot_phi2s_tp(self,key_list,index,deltax_axis = 20,deltay_axis = 20,figsize_x = 10,figsize_y = 5,save = False):
                self.plot_lpfield_tp(key_list,index,self.phi2s,'\u03C1'+ 'Q', 'kg/s',deltax_axis,deltay_axis,figsize_x,figsize_y,save)

        def plot_lpfield_tp(self, key_list, index, field_dict, name, units, deltax_axis, deltay_axis,figsize_x,figsize_y,save):
                fig, ax = plt.subplots(figsize=(figsize_x,figsize_y))
                ax.yaxis.set_major_locator(MultipleLocator(deltay_axis))
                ax.xaxis.set_major_locator(MultipleLocator(deltax_axis))
                
                max_field = -9999
                for R_key in range(len(self.list_Results)):
                    field = np.zeros((len(self.t),1))
                    for key in key_list:
                        if key != key_list[0]:
                            if self.lp_c[key_list[0]][1:-1][index] != self.lp_c[key][1:-1][index]:
                                field[:,0] += field_dict[self.list_names[R_key]][key][:,index]
                        else:
                            field[:,0] += field_dict[self.list_names[R_key]][key][:,index]                                                
                    line, = plt.plot(self.t ,abs(field[:,0]), label = self.list_names[R_key])
                    max_field = max(max_field, max(abs(field[:,0])))
                                
                plt.xlim([-deltax_axis*0.25, self.t[-1]+deltax_axis*0.25])
                plt.ylim([-deltay_axis*0.25,  1.05*max_field+deltay_axis*0.25])
                plt.grid(True)
#                plt.title('index = '+str(index),fontsize = 17) 
                plt.xlabel('t (s)', fontsize = 14); plt.ylabel(name +' ('+ units+')', fontsize = 14)
                
                plt.legend(handler_map= {}, loc = 'upper left')

                if save == True:
                    path = self.p+'/images'
                    fig.savefig(path+'/'+name+'_tp_'+str(index))
                    plt.close(fig)
                    
        def plot_timefield(self, field, name, units, firstvalue, save, clip = False, ymin = 0, ymax = 0, index = -1):
                fig, ax = plt.subplots(figsize=(5, 10))
                for R_key in range(len(self.list_Results)):
                    if index ==-1:
                        line, = plt.plot(self.t[firstvalue:] ,field[self.list_names[R_key]][firstvalue:], label = self.list_names[R_key])
                    else:
                        line, = plt.plot(self.t[firstvalue:] ,field[self.list_names[R_key]][:,index][firstvalue:], label = self.list_names[R_key])                        
                    
                plt.xlim([0, self.t[-1]])
                if clip == True:
                    plt.ylim([ymin,  ymax])
                plt.grid(True)
                plt.xlabel('t (s)'); plt.ylabel(name +' ('+ units+')')
                
                plt.legend(handler_map= {})

                if save == True:
                    path = self.p+'/images'
                    fig.savefig(path+'/'+name)
                    plt.close(fig)

        def plot_M(self,firstvalue = 0, save = False):
                self.plot_timefield(self.M, 'M', 'kg', firstvalue, save)

        def plot_V(self,firstvalue = 0, save = False, clip = False, ymin = 0, ymax = 0):
                self.plot_timefield(self.V, 'V', 'm³', firstvalue, save, clip, ymin, ymax)
                
        def plot_rcg_x(self,firstvalue = 0, save = False):
                self.plot_timefield(self.rcg, 'rcg_x', 'm', firstvalue, save, True, self.x[0], self.x[-1], 0)

        def plot_rcg_y(self,firstvalue = 0, save = False):
                self.plot_timefield(self.rcg, 'rcg_y', 'm', firstvalue, save, True, self.y[0], self.y[-1], 1)

        def plot_rcg_z(self,firstvalue = 0, save = False):
                self.plot_timefield(self.rcg, 'rcg_z', 'm', firstvalue, save, False, 0 , 0 , 2) 

        def plot_h_tp_time(self, key, index, deltax_axis = 20, deltay_axis = 20,figsize_x = 10,figsize_y = 5,save = False):
                self.plot_fieldtp_time(self.h_tp, key, index, 'h', 'm', deltax_axis, deltay_axis, 1, figsize_x,figsize_y,save)

        def plot_Us_m_tp_time(self, key, index, deltax_axis = 20, deltay_axis = 20, figsize_x = 10,figsize_y = 5,save = False):
                self.plot_fieldtp_time(self.Us_m_tp, key, index, 'Us', 'm/s', deltax_axis, deltay_axis, 1, figsize_x,figsize_y,save)
                
        def plot_deltac0_tp_time(self, key, index, sign, deltax_axis = 20, deltay_axis = 20, save = False):
                self.plot_fieldtp_time(self.deltac0_tp, key, index, 'deltac0', 'm', deltax_axis, deltay_axis, sign, save)

        def plot_deltah0_tp_time(self, key, index, sign, deltax_axis = 20, deltay_axis = 20, save = False):
                self.plot_fieldtp_time(self.deltah0_tp, key, index, 'deltah0', 'm', deltax_axis, deltay_axis, sign, save)

        def plot_fieldtp_time(self, field, key, index, name, units, deltax_axis, deltay_axis, sign, figsize_x,figsize_y, save):
                fig, ax = plt.subplots(figsize=(figsize_x,figsize_y))
                ax.yaxis.set_major_locator(MultipleLocator(deltay_axis))
                ax.xaxis.set_major_locator(MultipleLocator(deltax_axis))
                
                for R_key in range(len(self.list_Results)):
                    field_tp_time = np.zeros((len(self.t),1))
                    for t in range(len(self.t)):
                        if sign ==1:
                            field_tp_time[t,0] = max(field[self.list_names[R_key]][key][t][index])
                        elif sign ==-1:
                            field_tp_time[t,0] = min(field[self.list_names[R_key]][key][t][index])                    
                    
                    line, = plt.plot(self.t,field_tp_time[:,0], label = self.list_names[R_key])
                
                plt.grid(True)
#                tit = 'index = '+ str(index)
#                plt.title(tit,fontsize = 17) 
                plt.xlabel('t (s)', fontsize = 14); plt.ylabel(name +' ('+ units+')', fontsize = 14)                

                plt.legend(handler_map= {}, loc = 'upper left')

                if save == True:
                    path = self.p+'/images'
                    fig.savefig(path+'/'+name+'_tp_time_index_'+str(index))
                    plt.close(fig)

        def plot_Q(self,t,key_list,deltax_axis = 10,deltay_axis = 20):
                self.plot_lpfield(t, key_list, self.Q, 'Q', 'm³/s', deltax_axis, deltay_axis)

        def plot_phi2s(self,t,key_list,deltax_axis = 10,deltay_axis = 20):
                self.plot_lpfield(t, key_list, self.phi2s, '\u03C1'+ 'Q', 'kg/s', deltax_axis, deltay_axis)

        def plot_lpfield(self,t,key_list, field_dict, name, units, deltax_axis, deltay_axis):
                fig, ax = plt.subplots(figsize=(10, 5))
                j = self.t.index(t)
                ax.yaxis.set_major_locator(MultipleLocator(deltay_axis))
                ax.xaxis.set_major_locator(MultipleLocator(deltax_axis))
                
                max_field = -9999
                for R_key in range(len(self.list_Results)):
                    field = np.zeros((len(self.lp_c[key_list[0]][1:-1]),1))
                    for key in key_list:
                        for i in range(len(field)):
                            if key != key_list[0]:
                                if self.lp_c[key_list[0]][1:-1][i] != self.lp_c[key][1:-1][i]:
                                    field[i,0] += field_dict[self.list_names[R_key]][key][j,i]
                            else:
                                field[i,0] += field_dict[self.list_names[R_key]][key][j,i]                                                 
                    line, = plt.plot(self.lp[key_list[0]],abs(field[:,0]), label = self.list_names[R_key])
                    max_field = max(max_field, max(abs(field[:,0])))
                plt.xlim([0, self.lp[key_list[0]][-1]])
                plt.ylim([0,  1.05*max_field])
                plt.grid(True)
                plt.title('t = '+str(t)+ 's',fontsize = 17); plt.xlabel('l (m)'); plt.ylabel(name +' ('+ units+')')
                
                plt.legend(handler_map= {})

        def plot_phi2s_video(self,key_list,deltax_axis = 10,deltay_axis = 20):
                self.plot_lpfield_video(key_list, self.phi2s, '\u03C1'+ 'Q', 'kg/s', deltax_axis, deltay_axis)

        def plot_Q_video(self,key_list,deltax_axis = 10,deltay_axis = 20):
                self.plot_lpfield_video(key_list, self.Q, 'Q', 'm³/s', deltax_axis, deltay_axis)
 
        def plot_lpfield_video(self, key_list, field_dict, name, units, deltax_axis, deltay_axis):
                j1='imagen00'
                j2='imagen0'
                j3='imagen'
                
                make_dir(self.p, 'images')
                path = self.p+'/images'
                clean_dir(path, name)
                make_dir(path, name)
                
                dict = {}
                max_field = -9999
                for R_key in range(len(self.list_Results)):
                    field = np.zeros((len(self.t),len(self.lp[key_list[0]])))
    
                    for key in key_list:
                        for i in range(len(self.lp[key_list[0]])):
                            if key != key_list[0]:
                                if self.lp_c[key_list[0]][1:-1][i] != self.lp_c[key][1:-1][i]:
                                    field[:,i] += field_dict[self.list_names[R_key]][key][:,i]
                            else:
                                field[:,i] += field_dict[self.list_names[R_key]][key][:,i]
                                
                    dict[R_key] = field
                    max_field = max(max_field,np.amax(abs(field)))
                
                for t in range(len(self.t)):
                    fig, ax = plt.subplots(figsize=(10, 5))
                    plt.grid(which='major')
                    ax.yaxis.set_major_locator(MultipleLocator(deltay_axis))
                    ax.xaxis.set_major_locator(MultipleLocator(deltax_axis))
 
                    for R_key in range(len(self.list_Results)):                   
                        line, = plt.plot(self.lp[key] ,abs(dict[R_key][t,:]), label = self.list_names[R_key])
                    plt.title('t = '+str(self.t[t])+ 's',fontsize = 17); plt.xlabel('l (m)'); plt.ylabel(name +' ('+ units+')')
                    plt.ylim([0, max_field*1.05])
                    plt.xlim([0, self.lp[key][-1]])
                    
                    if t>=10 and t<100:
                        d=j2+str(t)
                    elif t<10:
                        d=j1+str(t)
                    else:
                        d=j3+str(t)
                        
                    plt.legend(handler_map= {})
                        
                    fig.savefig(self.p+'/images/'+name+'/'+d)
                    plt.close(fig)                    

        def plot_Sm_max(self, save = False):
                self.plot_field_max(self.Sm, 'Sm', 'm/s', save)

        def plot_h_max(self, save = False):
                self.plot_field_max(self.h, 'h', 'm', save)

        def plot_Us_m_max(self, save = False):
                self.plot_field_max(self.Us_m, 'Us_m', 'm/s', save)
                
        def plot_Cv_max(self, save = False):
                self.plot_field_max(self.Cv, 'Cv', '-', save)

        def plot_field_max(self, field, name, units, save, sign = 1):
                fig = plt.figure(figsize = (8,8))
                for R_key in range(len(self.list_Results)):
                    field_max = np.zeros((len(self.t),1))
                    for t in range(len(self.t)):
                        field_max[t,0] = np.amax(field[self.list_names[R_key]][t,:,:]*sign)*sign
                    line, = plt.plot(self.t,field_max[:,0], label = self.list_names[R_key])
                    
                plt.grid(True)
                plt.xlabel('t (s)'); 
                plt.ylabel(name +' ('+ units+')') 

                plt.legend(handler_map= {})

                if save == True:
                    path = self.p+'/images'
                    fig.savefig(path+'/'+name+'_max')
                    plt.close(fig)

                
class Comparison2:
        def __init__(self, path = '', list_list_names = []):
                self.p = path
                
                self.list_list_names = list_list_names
                self.list_list_Results = []
                self.list_list_paths = []                

                self.h = []
#                self.pb = {}
#                self.Cv = {}
                self.deltah0 = []
                self.deltac0 = []
                self.Us_m = []
#                self.tau = {}
                self.Q = []
#                self.phi2s = {}
                self.Sm = []
#                self.rho = {}                
                self.V = []
                self.M = []
                self.Cv_avrg = []                
#                self.Vsed = {}
                self.rcg = []
                
                self.z_tp = {}
                self.he_tp = {}
                self.h_tp = []
                self.Us_m_tp = []
                self.deltah0_tp = []
                self.deltac0_tp = []

                self.x = []
                self.y = []
                self.z = []
                self.t = []
                self.lp = {}
                self.lp_c = {}
                self.tp = {}
                
                self.get_case()

        def get_case(self):
                self.get_path_list()
                self.get_basic_data()
                
        def get_path_list(self):
                for i in range(len(self.list_list_names)):
                    list_Results = []
                    list_paths = []
                    for j in range(len(self.list_list_names[i])):
                        sub_listdir = os.listdir(self.p+'/'+self.list_list_names[i][j])
                        if 'Results' in sub_listdir:
                            list_paths.append(self.p+'/'+self.list_list_names[i][j])
                            list_Results.append(Results(self.p+'/'+self.list_list_names[i][j]))
                        
                    self.list_list_Results.append(list_Results)
                    self.list_list_paths.append(list_paths) 
                        
        def get_basic_data(self):
                self.x = self.list_list_Results[0][0].x
                self.y = self.list_list_Results[0][0].y
                self.z = self.list_list_Results[0][0].z
                self.t = self.list_list_Results[0][0].t
                self.lp = self.list_list_Results[0][0].lp
                self.lp_c = self.list_list_Results[0][0].lp_c
                self.tp = self.list_list_Results[0][0].tp  

        def get_V(self):
                for i in range(len(self.list_list_Results)):
                    dict = {}
                    for j in range(len(self.list_list_Results[i])):
                        self.list_list_Results[i][j].activate_V()
                        self.list_list_Results[i][j].get_V()
                        dict[self.list_list_names[i][j]] = self.list_list_Results[i][j].V
                        self.list_list_Results[i][j].clean_V()
                    self.V.append(dict)

        def get_Sm(self):
                for i in range(len(self.list_list_Results)):
                    dict = {}
                    for j in range(len(self.list_list_Results[i])):
                        self.list_list_Results[i][j].activate_Sm()
                        self.list_list_Results[i][j].get_Sm()
                        dict[self.list_list_names[i][j]] = self.list_list_Results[i][j].Sm
                        self.list_list_Results[i][j].clean_Sm()
                    self.Sm.append(dict)

        def get_h(self):
                for i in range(len(self.list_list_Results)):
                    dict = {}
                    for j in range(len(self.list_list_Results[i])):
                        self.list_list_Results[i][j].activate_h()
                        self.list_list_Results[i][j].get_h()
                        dict[self.list_list_names[i][j]] = self.list_list_Results[i][j].h
                        self.list_list_Results[i][j].clean_h()
                    self.h.append(dict)

        def get_Us_m(self):
                for i in range(len(self.list_list_Results)):
                    dict = {}
                    for j in range(len(self.list_list_Results[i])):
                        self.list_list_Results[i][j].activate_Us()
                        self.list_list_Results[i][j].get_Us()
                        dict[self.list_list_names[i][j]] = self.list_list_Results[i][j].Us_m
                        self.list_list_Results[i][j].clean_Us()
                    self.Us_m.append(dict)

        def get_deltac0(self):
                for i in range(len(self.list_list_Results)):
                    dict = {}
                    for j in range(len(self.list_list_Results[i])):
                        self.list_list_Results[i][j].activate_deltaz0()
                        self.list_list_Results[i][j].get_deltac0()
                        dict[self.list_list_names[i][j]] = self.list_list_Results[i][j].deltac0
                        self.list_list_Results[i][j].clean_deltac0()
                    self.deltac0.append(dict)

        def get_deltah0(self):
                for i in range(len(self.list_list_Results)):
                    dict = {}
                    for j in range(len(self.list_list_Results[i])):
                        self.list_list_Results[i][j].activate_deltaz0()
                        self.list_list_Results[i][j].get_deltah0()
                        dict[self.list_list_names[i][j]] = self.list_list_Results[i][j].deltah0
                        self.list_list_Results[i][j].clean_deltah0()
                    self.deltah0.append(dict)

        def get_M(self):
                for i in range(len(self.list_list_Results)):
                    dict = {}
                    for j in range(len(self.list_list_Results[i])):
                        self.list_list_Results[i][j].activate_M()
                        self.list_list_Results[i][j].get_M()
                        dict[self.list_list_names[i][j]] = self.list_list_Results[i][j].M
                        self.list_list_Results[i][j].clean_M()
                    self.M.append(dict)

        def get_Cv_avrg(self):
                for i in range(len(self.list_list_Results)):
                    dict = {}
                    for j in range(len(self.list_list_Results[i])):
                        self.list_list_Results[i][j].get_Cv_avrg()
                        dict[self.list_list_names[i][j]] = self.list_list_Results[i][j].Cv_avrg
                        self.list_list_Results[i][j].clean_Cv_avrg()
                    self.Cv_avrg.append(dict)
                    
        def get_rcg(self):
                for i in range(len(self.list_list_Results)):
                    dict = {}
                    for j in range(len(self.list_list_Results[i])):
                        self.list_list_Results[i][j].activate_rcg()
                        self.list_list_Results[i][j].get_rcg()
                        dict[self.list_list_names[i][j]] = self.list_list_Results[i][j].rcg
                        self.list_list_Results[i][j].clean_rcg()
                    self.rcg.append(dict)

        def get_Q(self):
                for i in range(len(self.list_list_Results)):
                    dict = {}
                    for j in range(len(self.list_list_Results[i])):
                        self.list_list_Results[i][j].activate_Q()
                        self.list_list_Results[i][j].get_Q()
                        dict[self.list_list_names[i][j]] = self.list_list_Results[i][j].Q
                        self.list_list_Results[i][j].clean_Q()
                    self.Q.append(dict)

        def get_he_tp(self):
                self.list_list_Results[0][0].get_he_tp()
                self.he_tp = self.list_list_Results[0][0].he_tp
                self.list_list_Results[0][0].clean_he()

        def get_z_tp(self):
                self.list_list_Results[0][0].get_z_tp()
                self.z_tp = self.list_list_Results[0][0].z_tp
                self.list_list_Results[0][0].clean_z()

        def get_deltac0_tp(self):
                for i in range(len(self.list_list_Results)):
                    dict = {}
                    for j in range(len(self.list_list_Results[i])):
                        self.list_list_Results[i][j].activate_deltaz0()
                        self.list_list_Results[i][j].get_deltac0_tp()
                        dict[self.list_list_names[i][j]] = self.list_list_Results[i][j].deltac0_tp
                        self.list_list_Results[i][j].clean_deltac0()
                    self.deltac0_tp.append(dict)

        def get_deltah0_tp(self):
                for i in range(len(self.list_list_Results)):
                    dict = {}
                    for j in range(len(self.list_list_Results[i])):
                        self.list_list_Results[i][j].activate_deltaz0()
                        self.list_list_Results[i][j].get_deltah0_tp()
                        dict[self.list_list_names[i][j]] = self.list_list_Results[i][j].deltah0_tp
                        self.list_list_Results[i][j].clean_deltah0()
                    self.deltah0_tp.append(dict)

        def get_h_tp(self, Max = False):
                for i in range(len(self.list_list_Results)):
                    dict = {}
                    for j in range(len(self.list_list_Results[i])):
                        self.list_list_Results[i][j].activate_h()
                        self.list_list_Results[i][j].get_h_tp(Max)
                        dict[self.list_list_names[i][j]] = self.list_list_Results[i][j].h_tp
                        self.list_list_Results[i][j].clean_h()
                    self.h_tp.append(dict)

        def get_Us_m_tp(self, Max = False):
                for i in range(len(self.list_list_Results)):
                    dict = {}
                    for j in range(len(self.list_list_Results[i])):
                        self.list_list_Results[i][j].activate_Us()
                        self.list_list_Results[i][j].get_Us_m_tp(Max)
                        dict[self.list_list_names[i][j]] = self.list_list_Results[i][j].Us_m_tp
                        self.list_list_Results[i][j].clean_Us()
                    self.Us_m_tp.append(dict)
 
        def plot_timefield(self, field, name, units, firstvalue, lastvalue, save, figsize_x, figsize_y, clip = False, ymin = 0, ymax = 0, index = -1, lg_loc = 'upper left'):
                fig = plt.subplots(figsize=(figsize_x, figsize_y))
                if lastvalue != -1:
                    lastvalue = self.t.index(lastvalue)
                else:
                    lastvalue = len(self.t)-1
                for i in range(len(self.list_list_Results)):
                    plt.subplot(1,len(self.list_list_Results),i+1)
                    for j in range(len(self.list_list_names[i])):
                        case = self.list_list_names[i][j]
                        if index ==-1:
                            line, = plt.plot(self.t[firstvalue:lastvalue+1] ,field[i][case][firstvalue:lastvalue+1], label = case)
                        else:
                            line, = plt.plot(self.t[firstvalue:lastvalue+1] ,field[i][case][:,index][firstvalue:lastvalue+1], label = case)
                    
                    plt.xlim([0, self.t[lastvalue]])
                    if clip == True:
                        plt.ylim([ymin,  ymax])
                    plt.grid(True)
                    plt.xlabel('t (s)', fontsize = 14)
                    if i == 0:
                        plt.ylabel(name +' ('+ units+')', fontsize = 14)
                    else:
                        plt.tick_params(labelleft = False)
                    
                    plt.legend(handler_map= {}, loc=lg_loc)
    
                plt.subplots_adjust(wspace=0.05)
                
                if save == True:
                    path = self.p+'/images'
                    fig.savefig(path+'/'+name)
                    plt.close(fig)

        def plot_M(self,firstvalue = 0, lastvalue = -1, save = False, figsize_x = 15, figsize_y = 10, clip = False, ymin = 0, ymax = 0, lg_loc = 'upper left'):
                self.plot_timefield(self.M, 'M', 'kg', firstvalue, lastvalue, save, figsize_x, figsize_y, clip, ymin, ymax,-1,lg_loc)

        def plot_V(self,firstvalue = 0, lastvalue = -1, save = False, figsize_x = 15, figsize_y = 10, clip = False, ymin = 0, ymax = 0, lg_loc = 'upper left'):
                self.plot_timefield(self.V, 'V', 'm³', firstvalue, lastvalue, save, figsize_x, figsize_y, clip, ymin, ymax,-1,lg_loc)

        def plot_Cv_avrg(self,firstvalue = 0, lastvalue = -1, save = False, figsize_x = 15, figsize_y = 10, clip = False, ymin = 0, ymax = 0, lg_loc = 'upper left'):
                self.plot_timefield(self.Cv_avrg, 'Cv', '-', firstvalue, lastvalue, save, figsize_x, figsize_y, clip, ymin, ymax,-1,lg_loc)

        def plot_rcg_x(self,firstvalue = 0, lastvalue = -1, save = False, figsize_x = 15, figsize_y = 10, lg_loc = 'upper right'):
                self.plot_timefield(self.rcg, 'x', 'm', firstvalue, lastvalue, save, figsize_x, figsize_y, True, self.x[0], self.x[-1],0,lg_loc)

        def plot_rcg_y(self,firstvalue = 0, lastvalue = -1, save = False, figsize_x = 15, figsize_y = 10, lg_loc = 'upper right'):
                self.plot_timefield(self.rcg, 'y', 'm', firstvalue, lastvalue, save, figsize_x, figsize_y, True, self.y[0], self.y[-1],1,lg_loc)

        def plot_rcg_z(self,firstvalue = 0, lastvalue = -1, save = False, figsize_x = 15, figsize_y = 10, clip = False, ymin = 0, ymax = 0, lg_loc = 'upper right'):
                self.plot_timefield(self.rcg, 'z', 'm', firstvalue, lastvalue, save, figsize_x, figsize_y, clip, ymin, ymax,2,lg_loc) 

        def plot_Q_tp(self,key_list,index, nx, ny, firstvalue = 0, lastvalue = -1, deltax_axis = 20,deltay_axis = 20, save = False,clip = False, ymin = 0, ymax = 0, lg_loc= 'upper right', figsize_x = 15, figsize_y = 10):
                self.plot_lpfield_tp(key_list,index,self.Q,'Q','m³/s', nx, ny, firstvalue, lastvalue, deltax_axis,deltay_axis,save,clip,ymin,ymax,lg_loc,figsize_x,figsize_y)

        def plot_lpfield_tp(self, key_list, index, field_dict, name, units, nx, ny, firstvalue, lastvalue, deltax_axis, deltay_axis, save,clip, ymin, ymax, lg_loc,figsize_x,figsize_y):
                fig, ax = plt.subplots(figsize=(figsize_x, figsize_y))
                ax.yaxis.set_major_locator(MultipleLocator(deltay_axis))
                ax.xaxis.set_major_locator(MultipleLocator(deltax_axis))

                if lastvalue != -1:
                    lastvalue = self.t.index(lastvalue)
                else:
                    lastvalue = len(self.t)-1

                for i in range(len(self.list_list_Results)):
                    plt.subplot(nx,ny,i+1)
                    for j in range(len(self.list_list_names[i])):
                        case = self.list_list_names[i][j]
                        field = np.zeros((len(self.t),1))
                        for key in key_list:
                            if key != key_list[0]:
                                if self.lp_c[key_list[0]][1:-1][index] != self.lp_c[key][1:-1][index]:
                                    field[:,0] += field_dict[i][case][key][:,index]
                            else:
                                field[:,0] += field_dict[i][case][key][:,index]                                               
                        line, = plt.plot(self.t[firstvalue:lastvalue+1] ,abs(field[:,0][firstvalue:lastvalue+1]), label = case)
                                    
                    plt.xlim([0, self.t[lastvalue]])
                    if clip == True:
                        plt.ylim([ymin,  ymax])
                    plt.grid(True)
                    if i == 0 or i == len(self.list_list_Results)-2:
                        plt.ylabel(name +' ('+ units+')', fontsize = 14)
                    if i == len(self.list_list_Results)-1 or i == len(self.list_list_Results)-2:
                        plt.xlabel('t (s)', fontsize = 14)
                    else:
                        plt.tick_params(labelbottom = False)
                    
                    plt.legend(handler_map= {}, loc=lg_loc)

                plt.subplots_adjust(hspace=0.05, wspace=0.1)

                if save == True:
                    path = self.p+'/images'
                    fig.savefig(path+'/'+name+'_tp_'+str(index))
                    plt.close(fig)

        def plot_h_tp_time(self, key, index, nx, ny, firstvalue = 0, lastvalue = -1, save = False, clip = False, ymin = 0, ymax = 0, lg_loc = 'upper left'):
                self.plot_fieldtp_time(self.h_tp, key, index, 'h', 'm', nx, ny, firstvalue, lastvalue, save, clip, ymin, ymax, lg_loc)

        def plot_Us_m_tp_time(self, key, index,  nx, ny, firstvalue = 0, lastvalue = -1, save = False, clip = False, ymin = 0, ymax = 0, lg_loc = 'upper right'):
                self.plot_fieldtp_time(self.Us_m_tp, key, index, 'Us', 'm/s', nx, ny, firstvalue, lastvalue, save, clip, ymin, ymax, lg_loc)

        def plot_fieldtp_time(self, field, key, index, name, units, nx, ny, firstvalue, lastvalue, save, clip, ymin, ymax, lg_loc):
                fig = plt.figure(figsize = (15,7))
                if lastvalue != -1:
                    lastvalue = self.t.index(lastvalue)
                else:
                    lastvalue = len(self.t)-1

                for i in range(len(self.list_list_Results)):
                    plt.subplot(nx,ny,i+1)
                    for j in range(len(self.list_list_names[i])):
                        field_tp_time = np.zeros((len(self.t),1))
                        case = self.list_list_names[i][j]
                        for t in range(len(self.t)):
                            field_tp_time[t,0] = field[i][case][key][t][index]                  
                        
                        line, = plt.plot(self.t[firstvalue:lastvalue+1],field_tp_time[:,0][firstvalue:lastvalue+1], label = case)
                
                    plt.xlim([0, self.t[lastvalue]])
                    if clip == True:
                        plt.ylim([ymin,  ymax])
                    plt.grid(True)
                    plt.xlabel('t (s)', fontsize = 14)
                    if i == 0:
                        plt.ylabel(name +' ('+ units+')', fontsize = 14)
                    else:
                        plt.tick_params(labelleft = False)
    
                    plt.legend(handler_map= {}, loc=lg_loc)

                plt.subplots_adjust(wspace=0.05)

                if save == True:
                    path = self.p+'/images'
                    fig.savefig(path+'/'+name+'_tp_time_index_'+str(index))
                    plt.close(fig)

        def plot_Sm_max(self, save = False, lg_loc = 'upper right'):
                self.plot_field_max(self.Sm, 'ub', 'm/s', save, lg_loc)

        def plot_field_max(self, field, name, units, save, lg_loc, sign = 1):
                fig = plt.figure(figsize = (15,10))
                for i in range(len(self.list_list_Results)):
                    plt.subplot(len(self.list_list_Results)/2,len(self.list_list_Results)/2,i+1)
                    for j in range(len(self.list_list_names[i])):
                        case = self.list_list_names[i][j]
                        field_max = np.zeros((len(self.t),1))
                        for t in range(len(self.t)):
                            field_max[t,0] = np.amax(field[i][case][t,:,:]*sign)*sign
                        line, = plt.plot(self.t,field_max[:,0], label = case)
                    
                    plt.xlim([0, self.t[-1]])
                    plt.grid(True)
                    if i == 0 or i == len(self.list_list_Results)-2:
                        plt.ylabel(name +' ('+ units+')', fontsize = 14)
                    if i == len(self.list_list_Results)-1 or i == len(self.list_list_Results)-2:
                        plt.xlabel('t (s)', fontsize = 14)
                    else:
                        plt.tick_params(labelbottom = False)

                    plt.legend(handler_map= {}, loc=lg_loc)

                plt.subplots_adjust(hspace=0.05, wspace=0.15)

                if save == True:
                    path = self.p+'/images'
                    fig.savefig(path+'/'+name+'_max')
                    plt.close(fig)

        def plot_deltac0_tp(self,key,index,time,nx,ny,xmin = -1, xmax = -1,save = False, clip = False, ymin=0, ymax=0, lg_loc = 'upper center',figsize_x = 15,figsize_y=10):
                self.plot_field_tp(key,index,time,self.deltac0_tp,'z','m',nx,ny,xmin,xmax,save,clip,ymin,ymax,lg_loc,figsize_x,figsize_y)

        def plot_field_tp(self, key, index, time, field, name, units, nx, ny, xmin, xmax, save, clip, ymin, ymax, lg_loc,figsize_x,figsize_y):
                fig, ax = plt.subplots(figsize=(figsize_x, figsize_y))
                j = self.t.index(time)
                he_tp = np.array(self.he_tp[key][index])
                z_tp = np.array(self.z_tp[key][index])

                dists = [0]*len(self.tp[key][index])
                dist_max = distxy(self.tp[key][index][0], self.tp[key][index][-1])
                
                for i in range(len(dists)):
                    dists[i] = distxy(self.tp[key][index][0], self.tp[key][index][i])-dist_max/2

                if xmin != -1:
                    imin = int((xmin-dists[0])/dist_max*len(dists))
                else:
                    imin = 0
                if xmax != -1:
                    imax = int((xmax-dists[0])/dist_max*len(dists))+1
                else:
                    imax = len(dists)

                for i in range(len(self.list_list_Results)):
                    plt.subplot(nx,ny,i+1)
                    line1, = plt.plot(dists[imin:imax], (z_tp-he_tp)[imin:imax],label = 'erodible layer')

                    for k in range(len(self.list_list_names[i])):
                        case = self.list_list_names[i][k]
                        deltac0_tp = np.array(field[i][case][key][j][index])
                        line2, = plt.plot(dists[imin:imax], (deltac0_tp+z_tp)[imin:imax], label = case+' final bottom')                    

                    line3, = plt.plot(dists[imin:imax], z_tp[imin:imax], label = 'initial bottom') 

                    if clip == True:
                        plt.ylim([ymin,  ymax])                    
                    plt.grid(True)
                    if i == 0 or i == len(self.list_list_Results)-2:
                        plt.ylabel('z (m)', fontsize = 14)
                    else:
                        plt.tick_params(labelleft = False)
                    if i == len(self.list_list_Results)-1 or i == len(self.list_list_Results)-2:
                        plt.xlabel('x (m)', fontsize = 14)
                    else:
                        plt.tick_params(labelbottom = False)
    
                    plt.legend(handler_map= {}, loc=lg_loc) 

                plt.subplots_adjust(hspace=0.05, wspace=0.05)

                if save == True:
                    path = self.p+'/images'
                    fig.savefig(path+'/'+name+'_max')
                    plt.close(fig)

        def plot_bottom_tp(self, key, index, time, nx, ny, figsize_x = 15,figsize_y = 10, xmin = -1, xmax = -1, clip = False, ymin = 0, ymax = 0, lg_loc= 'upper center', save = False):
                fig, ax = plt.subplots(figsize=(figsize_x, figsize_y))
                j = self.t.index(time)
                he_tp = np.array(self.he_tp[key][index])
                z_tp = np.array(self.z_tp[key][index])

                dists = [0]*len(self.tp[key][index])
                dist_max = distxy(self.tp[key][index][0], self.tp[key][index][-1])
                
                for i in range(len(dists)):
                    dists[i] = distxy(self.tp[key][index][0], self.tp[key][index][i])-dist_max/2

                if xmin != -1:
                    imin = int((xmin-dists[0])/dist_max*len(dists))
                else:
                    imin = 0
                if xmax != -1:
                    imax = int((xmax-dists[0])/dist_max*len(dists))+1
                else:
                    imax = len(dists)

                for i in range(len(self.list_list_Results)):
                    plt.subplot(nx,ny,i+1)
                    line1, = plt.plot(dists[imin:imax], (z_tp-he_tp)[imin:imax],label = 'erodible layer')

                    for k in range(len(self.list_list_names[i])):
                        case = self.list_list_names[i][k]
                        if self.deltac0_tp[i][case] != {}:
                            deltac0_tp = np.array(self.deltac0_tp[i][case][key][j][index])
                            line2, = plt.plot(dists[imin:imax], (deltac0_tp+z_tp)[imin:imax], label = case+' final bottom')
                        elif self.deltah0_tp[i][case] != {}:
                            deltah0_tp = np.array(self.deltah0_tp[i][case][key][j][index])
                            line2, = plt.plot(dists[imin:imax], (deltah0_tp+z_tp)[imin:imax], label = case+' calculated erosion')

                    line3, = plt.plot(dists[imin:imax], z_tp[imin:imax], label = 'initial bottom') 

                    if clip == True:
                        plt.ylim([ymin,  ymax])                    
                    plt.grid(True)
                    if i == 0 or i == len(self.list_list_Results)-2:
                        plt.ylabel('z (m)', fontsize = 14)
                    else:
                        plt.tick_params(labelleft = False)
                    if i == len(self.list_list_Results)-1 or i == len(self.list_list_Results)-2:
                        plt.xlabel('x (m)', fontsize = 14)
                    else:
                        plt.tick_params(labelbottom = False)
    
                    plt.legend(handler_map= {}, loc=lg_loc) 

                plt.subplots_adjust(hspace=0.05, wspace=0.05)

                if save == True:
                    path = self.p+'/images'
                    fig.savefig(path+'/'+'bottom_max')
                    plt.close(fig)

        def plot_h_image(self,t,im_name,nx,ny,off_x = 0,off_y = 0,n_intervals = 8, save = False, figsize_x = 8, figsize_y = 8):
                self.plot_field_image(self.h,t,im_name,nx,ny,'h', 'm',off_x,off_y,n_intervals,save,figsize_x,figsize_y)

        def plot_Us_image(self,t,im_name,nx,ny,off_x = 0,off_y = 0,n_intervals = 8, save = False, figsize_x = 8, figsize_y = 8):
                self.plot_field_image(self.Us_m,t,im_name,nx,ny,'Us', 'm/s',off_x,off_y,n_intervals,save,figsize_x,figsize_y)

        def plot_Cv_image(self,t,im_name,nx,ny,off_x = 0,off_y = 0,n_intervals = 8, save = False, figsize_x = 8, figsize_y = 8):
                self.plot_field_image(self.Cv,t,im_name,nx,ny,'Cv', '-',off_x,off_y,n_intervals,save,figsize_x,figsize_y)

        def plot_deltac0_image(self,t,im_name,nx,ny,off_x = 0,off_y = 0,n_intervals = 8, save = False, figsize_x = 8, figsize_y = 8):
                self.plot_field_image(self.deltac0,t,im_name,nx,ny,'deltac0', 'm',off_x,off_y,n_intervals,save,figsize_x,figsize_y)

        def plot_field_image(self,field,t,im_name, nx, ny, name, units, off_x, off_y, n_intervals, save, figsize_x, figsize_y):
                im = plt.imread(self.p+'/'+im_name)
                fig, ax = plt.subplots(figsize=(figsize_x, figsize_y))
                extent = [self.x[0]+off_x,self.x[-1]+off_x,self.y[0]+off_y,self.y[-1]+off_y]
                
                colors = []
                for c in np.linspace(0,1,n_intervals+1):
                    if len(colors) > 1:
                        colors.append((c,abs(0.5-c),1-c,1))
                    elif len(colors) == 1:
                        colors.append((c,abs(0.5-c),1-c,0.5))
                    else:
                        colors.append((c,abs(0.5-c),1-c,0))
                mycmap = mcolors.ListedColormap(colors)

                j = self.t.index(t)

                for i in range(len(self.list_list_Results)):
                    case = self.list_list_names[i][0]
                    plt.subplot(nx,ny,i+1)
                    plt.imshow(im,extent = extent, aspect='auto')
                    plt.grid()
                                                       
                    field_t = field[i][case][j,:,:].transpose()
                    field_inv = field_t*0
                    nrows = field_t.shape[0]
                    for i in range(nrows):
                        field_inv[i,:] = field_t[nrows-1-i,:]
    
                    max_field = round(np.amax(field_inv),1)
                    a = [0,0.001]
                    ticks = [0]
                    for i in range(n_intervals):
                        a.append(round(max_field*(i+1)/(n_intervals),2))
                        ticks.append(round(max_field*(i+1)/(n_intervals),2))
                
                    a = np.array([a])
                    norm = mcolors.BoundaryNorm(a[0], len(a[0])-1)
                    img= plt.imshow(field_inv,cmap=mycmap,extent=extent,norm = norm)
                    cbar = fig.colorbar(img, ticks = ticks, spacing = 'proportional',label= name+' ('+units+')')
                    ticks_names = []
                    for tick in ticks: ticks_names.append(str(tick))
                    cbar.ax.set_yticklabels(ticks)

                plt.subplots_adjust(hspace=0.05, wspace=0.05)

                if save == True:
                    path = self.p+'/images'
                    fig.savefig(path+'/'+name+'_t_'+str(t))
                    plt.close(fig)

        def plot_hmax_image(self,t_final,im_name,nx,ny,off_x = 0,off_y = 0,clipp = False, xmin=0, xmax=0, ymin=0, ymax=0, figsize_x = 8, figsize_y = 8,n_intervals = 8, save = False):
                self.plot_fieldmax_image(self.h,t_final,im_name,nx,ny,'h', 'm',off_x, off_y, clipp, xmin, xmax, ymin, ymax, figsize_x, figsize_y, n_intervals, save)

        def plot_Usmax_image(self,t_final,im_name,nx,ny,off_x = 0,off_y = 0,clipp = False, xmin=0, xmax=0, ymin=0, ymax=0, figsize_x = 8, figsize_y = 8,n_intervals = 8, save = False):
                self.plot_fieldmax_image(self.Us_m,t_final,im_name,nx,ny,'Us', 'm/s',off_x, off_y, clipp, xmin, xmax, ymin, ymax, figsize_x, figsize_y, n_intervals, save)

        def plot_deltac0max_image(self,t_final,im_name,nx,ny,off_x = 0,off_y = 0,clipp = False, xmin=0, xmax=0, ymin=0, ymax=0, figsize_x = 8, figsize_y = 8,n_intervals = 8, save = False):
                self.plot_fieldmax_image(self.deltac0,t_final,im_name,nx,ny,'profundidad de erosión', 'm',off_x, off_y, clipp, xmin, xmax, ymin, ymax, figsize_x, figsize_y, n_intervals, save,-1)

        def plot_deltah0max_image(self,t_final,im_name,nx,ny,off_x = 0,off_y = 0,clipp = False, xmin=0, xmax=0, ymin=0, ymax=0, figsize_x = 8, figsize_y = 8,n_intervals = 8, save = False):
                self.plot_fieldmax_image(self.deltah0,t_final,im_name,nx,ny,'profundidad de erosión', 'm',off_x, off_y, clipp, xmin, xmax, ymin, ymax, figsize_x, figsize_y, n_intervals, save,-1)

        def plot_fieldmax_image(self,field,t_final,im_name, nx, ny, name, units, off_x, off_y, clipp, xmin, xmax, ymin, ymax, figsize_x, figsize_y, n_intervals, save, sign = 1):
                im = plt.imread(self.p+'/'+im_name)
                fig, ax = plt.subplots(figsize=(figsize_x, figsize_y))
                if clipp == False:
                    extent = [self.x[0]+off_x,self.x[-1]+off_x,self.y[0]+off_y,self.y[-1]+off_y]
                else:
                    extent = [self.x[0]+xmin+off_x,self.x[0]+xmax+off_x,self.y[0]+ymin+off_y,self.y[0]+ymax+off_y]
                    alpha_xmin = (xmin)/(self.x[-1]-self.x[0]); alpha_xmax = (xmax)/(self.x[-1]-self.x[0])
                    alpha_ymin = 1-(ymin)/(self.y[-1]-self.y[0]); alpha_ymax = 1-(ymax)/(self.y[-1]-self.y[0])
                    i_xmin = int(alpha_xmin*im.shape[1]); i_xmax = int(alpha_xmax*im.shape[1])+1
                    i_ymin = int(alpha_ymin*im.shape[0]); i_ymax = int(alpha_ymax*im.shape[0])+1
                    im = im[i_ymax:i_ymin, i_xmin:i_xmax]
                                                
                colors = []
                for c in np.linspace(0,1,n_intervals+1):
                    if len(colors) > 1:
                        colors.append((c,abs(0.5-c),1-c,1))
                    elif len(colors) == 1:
                        colors.append((c,abs(0.5-c),1-c,0.5))
                    else:
                        colors.append((c,abs(0.5-c),1-c,0))
                mycmap = mcolors.ListedColormap(colors)

                for p in range(len(self.list_list_Results)):
                    case = self.list_list_names[p][0]
                    plt.subplot(nx,ny,p+1)
                    plt.imshow(im,extent = extent, aspect='auto')    
                    plt.grid()
                    plt.ylabel(case, fontsize = 14)

#                    if p != len(self.list_list_Results)-1:
#                        plt.tick_params(labelbottom = False)
 
                    field_max = np.zeros((len(self.y), len(self.x)))
                    j = 0
                
                    while True:
                        field_t = field[p][case][j,:,:].transpose()
                        field_inv = field_t*0
                        nrows = field_t.shape[0]
                        for i in range(nrows):
                            field_inv[i,:] = field_t[nrows-1-i,:]
                        for i in range(field_t.shape[0]):
                            for k in range(field_t.shape[1]):
                                field_max[i,k] = max(field_max[i,k]*sign, field_inv[i,k]*sign)*sign
                        if self.t[j] >= t_final:
                            break                    
                        j += 1
    
                    max_field = round(np.amax(field_max*sign),3)
                    a = [0,0.001]
                    ticks = [0]
                    for i in range(n_intervals):
                        a.append(round(max_field*(i+1)/(n_intervals),2))
                        ticks.append(round(max_field*(i+1)/(n_intervals),2))

                    a = np.array([a])
                    norm = mcolors.BoundaryNorm(a[0], len(a[0])-1)
                    if clipp == True:
                        i_xmin = int(xmin/(self.x[1]-self.x[0])); i_xmax = int(xmax/(self.x[1]-self.x[0]))
                        i_ymin = int((self.y[-1]-ymin)/(self.y[1]-self.y[0])); i_ymax = int((self.y[-1]-ymax)/(self.y[1]-self.y[0]))
                        field_max = field_max[i_ymax:i_ymin,i_xmin:i_xmax]
                    img= plt.imshow(field_max*sign,cmap=mycmap,extent=extent,norm = norm)
                    cbar = fig.colorbar(img, pad = 0.025, ticks = ticks, spacing = 'proportional')
                    cbar.ax.set_ylabel(name+' ('+units+')',  fontsize = 12)
                    ticks_names = []
                    for tick in ticks: ticks_names.append(str(tick))
                    cbar.ax.set_yticklabels(ticks)
                    
                plt.subplots_adjust(hspace=-0.5)

                if save == True:
                    path = self.p+'/images'
                    fig.savefig(path+'/'+name+'_max')
                    plt.close(fig)

def clean_dir(path, dir, rank = 0):
    if rank == 0:
        listdir = os.listdir(path)
        if dir in listdir:
            path_dir = path+'/'+dir
            for filename in os.listdir(path_dir):
                file_path = os.path.join(path_dir, filename)
                try:
                    if os.path.isfile(file_path) or os.path.islink(file_path):
                        os.unlink(file_path)
                    elif os.path.isdir(file_path):
                        shutil.rmtree(file_path)
                except Exception as e:
                    print('Failed to delete %s. Reason: %s' % (file_path, e))
        
            os.chdir(path)
            os.rmdir(path_dir)

def make_dir(path, dir, rank = 0):
    if rank == 0:
        listdir = os.listdir(path)
        if not(dir in listdir):
            os.mkdir(path+'/'+dir)